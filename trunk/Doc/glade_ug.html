<html lang="en">
<head>
<title>GLADE User's Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GLADE User's Guide">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<h1 class="settitle">GLADE User's Guide</h1>
<div class="node">
<p><hr>
<a name="Top"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#About-This-Guide">About This Guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>
<br>
</div>

<h2 class="unnumbered">GLADE User Guide</h2>

<p>GLADE is the GNAT implementation of the Ada95 Distributed Systems Annex.

<p class="noindent">GLADE, GNAT Library for Ada Distributed Environment<br>
GLADE Version glade-2007

<p class="noindent">Document revision level $Revision$<br>
Date:  $Date$

   <p>Copyright &copy; 1997-2006, Free Software Foundation

   <p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1
or any later version published by the Free Software Foundation;
with the Invariant Sections being &ldquo;GNU Free Documentation License&rdquo;, with the
Front-Cover Texts being
&ldquo;GLADE User's Guide / GNAT Library for Ada Distributed Environment&rdquo;,
and with no Back-Cover Texts. 
A copy of the license is included in the section entitled
&ldquo;GNU Free Documentation License&rdquo;.

<ul class="menu">
<li><a accesskey="1" href="#About-This-Guide">About This Guide</a>
<li><a accesskey="2" href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>
<li><a accesskey="3" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<li><a accesskey="4" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<li><a accesskey="5" href="#DSA-and-CORBA">DSA and CORBA</a>
<li><a accesskey="6" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>
</ul>

<div class="node">
<p><hr>
<a name="About-This-Guide"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="unnumbered">About This Guide</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-This-Guide-Contains">What This Guide Contains</a>
</ul>

<div class="node">
<p><hr>
<a name="What-This-Guide-Contains"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#About-This-Guide">About This Guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#About-This-Guide">About This Guide</a>
<br>
</div>

<h3 class="unnumberedsec">What This Guide Contains</h3>

<p class="noindent">This guide contains the following chapters:

     <ul>
<li><a href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>, describes different ways to
develop systems that must run on networks of computers.

     <li><a href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>, discusses the features presented
in Annex E of the Ada 95 language reference. This chapter provides a tutorial
for beginners and includes several useful examples for more advanced
programmers.

     <li><a href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>, describes how to use the configuration
tool <tt>gnatdist</tt>. It also describes in detail the default GLADE
Partition Communication Subsystem, GARLIC.

     <li><a href="#DSA-and-CORBA">DSA and CORBA</a>, is a detailed comparison between the capabilities of
 CORBA and those of the Distributed System Annex.

     <li><a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>, contains the text of the license
 under which this document is being distributed.

   </ul>

<div class="node">
<p><hr>
<a name="Introduction-to-Distributed-Systems"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#About-This-Guide">About This Guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">1 Introduction to Distributed Systems</h2>

<p>A distributed system architecture comprises a network of computers and the
software components that execute on those computers. Such architectures are
commonly used to improve the performance, reliability, and reusability of
complex applications. Typically, there is no shared address space
available to remotely-located components (that is to say, components running
on different nodes of the network), and therefore these components must
communicate using some form of message-passing.

<ul class="menu">
<li><a accesskey="1" href="#Using-OS-Network-Services">Using OS Network Services</a>
<li><a accesskey="2" href="#Using-a-Middleware-Environment">Using a Middleware Environment</a>
<li><a accesskey="3" href="#Using-a-Distributed-Language">Using a Distributed Language</a>
</ul>

<div class="node">
<p><hr>
<a name="Using-OS-Network-Services"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Using-a-Middleware-Environment">Using a Middleware Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>
<br>
</div>

<h3 class="section">1.1 Using OS Network Services</h3>

<p>There are several programming techniques for developing distributed
applications. These applications have traditionally been developed using
network programming interfaces such as sockets. Programmers explicitly
have to perform calls to operating system services, a task that can be
tedious and error-prone. This includes initializing socket connection
and determining peer location, marshaling and unmarshaling data
structures, sending and receiving messages, debugging and testing
several programs at the same time, and porting the application to several
platforms to uncover subtle differences between various network interfaces.

   <p>Of course, this communication code can be encapsulated in wrappers to reduce
its complexity, but it is clear that most of it can be automatically
generated. Message passing diverts developer's attention from the
application domain. The query and reply scenario is a classical scheme
in distributed applications; using message passing for such a scheme
can be compared to using a &ldquo;goto&rdquo; mechanism in a non-distributed
application.  This is considered unacceptable methodology in modern software
engineering. A more robust design is be to use a
structured approach based on procedure calls.

   <p>In some respects, network programming can be compared to the
multi-threading programming issue. The user can decide to split his code
into several pieces and to multiplex the thread executions himself, using a
table-driven model. The scheduling code ends up embedded into the user
code. This solution is error-prone and fragile in regard to any future
modification. Relying on an implementation of threads such as provided in
POSIX is a better solution. Relying on language primitives that support
concurrency, such as Ada tasks, is best.

<div class="node">
<p><hr>
<a name="Using-a-Middleware-Environment"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Using-a-Distributed-Language">Using a Distributed Language</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-OS-Network-Services">Using OS Network Services</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>
<br>
</div>

<h3 class="section">1.2 Using a Middleware Environment</h3>

<p>A middleware environment is intended to provide high level abstractions
in order to easily develop user applications.  Environments like CORBA
or Distributed Computing Environment (DCE) provide a framework to
develop client/server applications based on the Remote Procedure Call model
(RPC). The RPC model is inspired from the query and reply
scheme. In rough analogy with a regular procedure call, arguments are pushed
onto a stream, along with some data specifying the remote procedure to
be executed. The stream is transmitted over the network to the
server. The server decodes the stream, performs the regular subprogram call
locally, and then puts the output parameters into another stream, along with the
exception (if any) raised by the subprogram execution. The server then
sends this stream back to the caller. The caller decodes the stream and raises
locally the exception if needed.

   <p>CORBA provides the same enhancements to the remote procedure model that
object-oriented languages provide to classical procedural languages.  These
enhancements include encapsulation, inheritance, type checking, and
exceptions. These features are offered through an Interface Definition
Language (IDL).

   <p>The middleware communication framework provides all the machinery to
perform, somewhat transparently, remote procedure calls or remote object
method invocations. For instance, each CORBA interface communicates
through an Object Request Broker (ORB). A communication subsystem such
as an ORB is intended to allow applications to use objects without being
aware of their underlying message-passing implementation. In addition. the user
may also require a number of more complex services to develop his
distributed application. Some of these services are indispensable, for example
a location service that allows clients to reference remote services via
higher level names, instead of a traditional scheme for addressing remote
services that use Internet host addresses and communication port
numbers. Other services provide domain-independent interfaces that are
frequently used by distributed applications.

   <p>If we return to the multi-thread programming comparison, the
middleware solution is close to what a POSIX library or a language like
Esterel<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>
would provide for developing concurrent applications. A middleware
framework like DCE is close to a POSIX library in terms of abstraction
levels. Functionalities are very low-level and very complex. CORBA is
closer to Esterel in terms of development process.  The control part of
the application can be specified in a description language. The
developer then has to fill-in automatically generated source code templates
(stub and skeletons) to build the computational part of the application. The
distribution is a pre-compilation process and the distributed boundaries
are always explicit. Using CORBA, the distributed part is written in IDL
and the core of the application is written in a host language such as C++.

<div class="node">
<p><hr>
<a name="Using-a-Distributed-Language"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-a-Middleware-Environment">Using a Middleware Environment</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>
<br>
</div>

<h3 class="section">1.3 Using a Distributed Language</h3>

<p>Rather than defining a new language like the CORBA IDL, an alternative is
to extend an existing programming language with the addition of distributed
features. The distributed object paradigm provides a more
object-oriented approach to programming distributed systems. The notion
of a distributed object is an extension to the abstract data type that
allows the services provided in the type interface to be called
independently of where the actual service is executed. When combined
with object-oriented features such as inheritance and polymorphism,
distributed objects offer a more dynamic and structured computational
environment for distributed applications.

   <p>The Distributed Systems Annex (DSA) of Ada95 defines several
extensions that allow the user to write a distributed system entirely in
Ada.  The types of distributed objects, the services they provide, and
the bodies of the remote methods to be executed are all defined in conventional
Ada packages. The Ada95 model is analogous the Java/RMI model. 
In both languages, the IDL is replaced by  well-defined language constructs. 
Therefore, the language supports both remote procedure
calls and remote object method invocations transparently, and the semantics
of distribution are consistent with the rest of the language.

   <p>A program written in such a language is intended to communicate with a
program written in the same language, but this apparent restriction has
several useful consequences. The language can provide more powerful
features because it is not constrained by the common features available
in all host languages. In Ada95, the user will define a specification of
remote services and implement them exactly as he would for ordinary,
non-distributed services. His Ada95 environment will compile them to
produce a stub file (on the caller side) and a skeleton file that
automatically includes the body of the services (on the receiver
side). Creating objects, obtaining or registering object references or
adapting the object skeleton to the user object implementation are made
transparent because the language environment has a full control on the
development process.

   <p>Comparing with multi-thread programming once again, the language
extension solution is equivalent to the solution adopted for tasking
facilities in Ada.  Writing a distributed application is as simple as
writing a concurrent application: there is no binding consideration and
no code to wrap.  The language and its run-time system take care of
most issues that would divert the programmer's attention from the
application domain.

<div class="node">
<p><hr>
<a name="The-Distributed-Systems-Annex"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-Distributed-Systems">Introduction to Distributed Systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">2 The Distributed Systems Annex</h2>

<p>A critical feature of the Distributed Systems Annex (DSA) is that it allows the
user to develop his application the same way whether this application is
going to be executed as several programs on a distributed system, or as a
single program on a non-distributed system. The DSA has been designed
to minimize the source changes needed to convert
an ordinary non-distributed program into a distributed program.

   <p>The simplest way to start with DSA is to develop the
application on a non-distributed system. Of course, the design of the
application should take into account the fact that some units are going
to be accessed remotely. In order to write an Ada95 distributed program,
it is necessary for the user to label by means of categorization pragmas
some of library level compilation units of the application program. The units
which require
categorization are typically those that are called remotely, and those
that provide the types used in remote invocations.

   <p>In order to insure that distributed execution is possible, these units are
restricted to contain only a limited set of Ada constructs. 
For instance, if the distributed system has no shared memory,
shared variables must be forbidden. To specify the nature of these restrictions,
the DSA provides different categorization pragmas, each of which excludes some
language constructs from the categorized package.

   <p>Of course, the user can develop the non-distributed application with his
usual software engineering environment. It is critical to note that the
user needs no specialized tools to develop his/her distributed
application. For instance, he can debug his application with the usual
debugger. Note that a non-distributed program is not to be confused with
a distributed application composed of only one program. The later is
built with the help of the configuration tool and includes the
communication library.

   <p>Once the non-distributed version of the program is complete, it has to
be configured into separate partitions, This step is surprisingly
simple, compared to that of developing the application itself. The
configuration step consists in mapping sets of compilation units into
individual partitions, and specifying the mapping between partitions and
nodes in the computer network. This mapping is specified and managed by
means of GLADE.

   <p>The distributed version of the user application should work as is, but
even when a program can be built both as a non-distributed or a
distributed program using the same source code, there may still be
differences in program execution between the distributed and
non-distributed versions. These differences are discussed in subsequent
sections (see <a href="#Pragma-Asynchronous">Pragma Asynchronous</a> and <a href="#Pragma-All_005fCalls_005fRemote">Pragma All_Calls_Remote</a>).

   <p>Developing a non-distributed application in order to distribute it
later is the natural approach for a novice. Of course, it is not always
possible to write a distributed application as a non-distributed
application. For instance, a client/server application does not belong
to this category because several instances of the client can be active
at the same time. It is very easy to develop such an application using
GLADE; we shall describe how to do this in the following sections.

<ul class="menu">
<li><a accesskey="1" href="#Architecture-of-a-Distributed-Ada95-Application">Architecture of a Distributed Ada95 Application</a>
<li><a accesskey="2" href="#Categorization-Pragmas">Categorization Pragmas</a>
<li><a accesskey="3" href="#Pragma-Declared-Pure">Pragma Declared Pure</a>
<li><a accesskey="4" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>
<li><a accesskey="5" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>
<li><a accesskey="6" href="#Pragma-Shared_005fPassive">Pragma Shared_Passive</a>
<li><a accesskey="7" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<li><a accesskey="8" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>
<li><a accesskey="9" href="#Most-Features-in-One-Example">Most Features in One Example</a>
</ul>

<div class="node">
<p><hr>
<a name="Architecture-of-a-Distributed-Ada95-Application"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Categorization-Pragmas">Categorization Pragmas</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.1 Architecture of a Distributed Ada95 Application</h3>

<p>A distributed system is an interconnection of one or more processing
nodes and zero or more storage nodes. A distributed program comprises
one or more partitions. A partition is an aggregate of library
units. Partitions communicate through shared data or RPCs. A passive
partition has no thread of control. Only a passive partition can be
configured on a storage node. An active partition has zero or more
threads of control and has to be configured on a processing node.

   <p>The library unit is the core component of an Ada95 distributed
application. The user can explicitly assign library units to a
partition. Partitioning is a post-compilation process. The user
identifies interface packages at compile-time. These packages are
categorized using pragmas. Each of these pragmas supports the use of one of
the following classical paradigms:

     <ul>
<li>Remote subprograms:
For the programmer, a remote subprogram call is similar to a regular
subprogram call. Run-time binding using access-to-subprogram types can
also be used with remote subprograms. These remote subprograms are
mostly declared in library units categorized as remote call interface
(RCI).

     <li>Distributed objects:
Special-purpose access types can be defined which designate remote
objects. When a primitive dispatching operation is invoked on an object
designated by such a remote access, a remote call is performed transparently
on the partition on which the object resides. The types of these distributed
objects are declared in library units categorized as remote types (RT).

     <li>Shared objects:
Global data can be shared between active partitions, providing a
repository similar to a shared memory, a shared file system or a
database. Entry-less protected objects allow safe concurrent access and update
shared objects. This feature is orthogonal to the notion of distributed
objects, which are only accessed through exported services. These shared
objects are declared in library units categorized as shared passive (SP).

   </ul>

   <p>The remotely-called subprograms declared in a library unit categorized
as remote call interface (RCI) or remote types (RT) may be either
statically or dynamically bound. The partition on which a statically
bound remote subprogram is executed can be determined before the
call. This is a static remote subprogram call. In contrast, A remote method or
a dereference of an access to remote subprogram are dynamically bound remote
calls, because the partition on which the remote subprogram is executed
is determined at runtime, by the actuals of the call.

   <p>In the following example, Data_1 and Data_2 are shared passive (SP)
library units. Data_1 is configured on a passive partition mapped on a
storage node. Partition_1 and Partition_2 are active partitions. Note
that under some circumstances, a partition, for instance Partition_2,
can be duplicated. To be duplicated, Unit_2 and Unit_3 which are
configured on Partition_2 have to provide only dynamically bound remote
subprograms. Otherwise, a partition calling a remote subprogram on
Unit_2 would not be able to statically determine where to perform the
remote call between the two instances of Unit_2.

   <p><br>
<br>
<img src="xe-arch.fig.jpg" alt="xe-arch.fig.jpg">
<br>

<div class="node">
<p><hr>
<a name="Categorization-Pragmas"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Declared-Pure">Pragma Declared Pure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Architecture-of-a-Distributed-Ada95-Application">Architecture of a Distributed Ada95 Application</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.2 Categorization Pragmas</h3>

<p>Library units can be categorized according to the role they play in a
distributed program. A categorization pragma is a library unit pragma
that restricts the kinds of declarations that can appear in a library unit
and possibly in its child units, as well as the legal semantic dependences
that the categorized unit can have. There are several categorization
pragmas :

     <ul>
<li>Remote_Call_Interface
<li>Remote_Types
<li>Shared_Passive
<li>Pure
</ul>

   <p>The following paragraphs do not present the detailed semantics of these
pragmas (formal details will be found in the Ada95 Reference Manual). 
Their purpose is to give the reader an intuitive overview of
the purpose of these pragmas. If a library unit is not categorized, this
unit is called a normal unit and plays no special role in the distributed
application. Such a unit is duplicated on any partition in which it is
mentioned.

   <p>A parenthetical remark: to avoid the need for specific run-time
libraries for the DSA, the notion of remote rendezvous has not been
introduced in Ada95: tasks cannot be invoked directly from one partition
to another. Therefore, declarations of task types and general protected types
with entries are not allowed in categorized Ada library units.

<div class="node">
<p><hr>
<a name="Pragma-Declared-Pure"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Categorization-Pragmas">Categorization Pragmas</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.3 Pragma Declared Pure</h3>

<p>This pragma is not specific to the Distributed Systems Annex. A pure
package can appear in the context of any package, categorized or not. 
A pure package is a preelaborable package that
does not contain the declaration of any variable or named access
type. It is particularly useful to define types, constants and
subprograms shared by several categorized packages. In contrast, normal
packages cannot appear in the context of categorized package declarations. 
Because a pure package has no state, it can be duplicated on several partitions.

<div class="node">
<p><hr>
<a name="Pragma-Remote_005fCall_005fInterface"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Declared-Pure">Pragma Declared Pure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.4 Pragma Remote_Call_Interface</h3>

<ul class="menu">
<li><a accesskey="1" href="#Overview-of-Pragma-Remote_005fCall_005fInterface">Overview of Pragma Remote_Call_Interface</a>
<li><a accesskey="2" href="#Regular-Remote-Subprograms-_0028RCI_0029">Regular Remote Subprograms (RCI)</a>
<li><a accesskey="3" href="#Remote-Access-to-Subprograms-_0028RAS_0029">Remote Access to Subprograms (RAS)</a>
<li><a accesskey="4" href="#Remote-Access-to-Class-Wide-Types-_0028RACW_0029">Remote Access to Class Wide Types (RACW)</a>
<li><a accesskey="5" href="#Summary-on-Pragma-Remote_005fCall_005fInterface">Summary on Pragma Remote_Call_Interface</a>
</ul>

<div class="node">
<p><hr>
<a name="Overview-of-Pragma-Remote_005fCall_005fInterface"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Regular-Remote-Subprograms-_0028RCI_0029">Regular Remote Subprograms (RCI)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>
<br>
</div>

<h4 class="subsection">2.4.1 Overview of Pragma Remote_Call_Interface</h4>

<p>Library units categorized with this pragma declare subprograms that can be
called and executed remotely. An RCI unit acts as a server for remote calls. 
There is no memory space shared between server and clients. 
A subprogram call that invokes one such
subprogram is a classical RPC operation; it is a
statically bound operation, because the compiler can determine the identity
of the subprogram being called.

   <p>Dynamically bound calls are provided through two mechanisms:

     <ul>
<li>The dereference of an access_to_subprogram value, i.e. a value whose type is
a remote_access_to_subprogram (RAS).

     <li>A dispatching call whose controlling argument is
an access-to-class-wide operand,  (remote access on class wide
types - RACW). These remote access types can be declared in a RCI
package as well.

   </ul>

   <p>A remote access type (RAS or RACW) can be viewed as a fat pointer, that is
to say a structure with a remote address and a local address (like an URL:
<tt>&lt;protocol&gt;</tt>://<tt>&lt;remote</tt><code>-</code><tt>machine&gt;</tt>/<tt>&lt;local</tt><code>-</code><tt>directory&gt;</tt>). The
remote address must denote the host of the partition on which the entity has
been created; the local address describes the local memory
address within the host.

   <p>It is very unlikely that RCI units can be duplicated in the distributed
system. An implementation may allow separate copies of a RCI unit as
long as it ensures that the copies present a consistent state to all clients. 
In the general case, preserving consistency is very costly. For this reason, the
implementation may require a RCI unit to be unique in the distributed
system.

<div class="node">
<p><hr>
<a name="Regular-Remote-Subprograms-_0028RCI_0029"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Remote-Access-to-Subprograms-_0028RAS_0029">Remote Access to Subprograms (RAS)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview-of-Pragma-Remote_005fCall_005fInterface">Overview of Pragma Remote_Call_Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>
<br>
</div>

<h4 class="subsection">2.4.2 Regular Remote Subprograms (RCI)</h4>

<p>In the following example, a RCIBank offers several remote services:
Balance, Transfer, Deposit and Withdraw. On the caller side, the bank
client uses the stub files of unit RCIBank. On the receiver side,
the bank receiver uses the skeleton files of unit RCIBank including
the body of this package.

<pre class="smallexample">     
     <b>package</b> Types <b>is</b>
        <b>pragma</b> Pure;
     
        <b>type</b> Customer_Type <b>is</b> <b>new</b> String;
        <b>type</b> Password_Type <b>is</b> <b>new</b> String;
     <b>end</b> Types;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> Types; <b>use</b> Types;
     <b>package</b> RCIBank <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>function</b> Balance
          (Customer : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type)
           <b>return</b> Integer;
     
        <b>procedure</b> Transfer
          (Payer    : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type;
           Amount   : <b>in</b> Positive;
           Payee    : <b>in</b> Customer_Type);
     
        <b>procedure</b> Deposit
          (Customer : <b>in</b> Customer_Type;
           Amount   : <b>in</b> Positive);
     
        <b>procedure</b> Withdraw
          (Customer : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type;
           Amount   : <b>in</b> <b>out</b> Positive);
     <b>end</b> RCIBank;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> Types; <b>use</b> Types;
     <b>with</b> RCIBank; <b>use</b> RCIBank;
     <b>procedure</b> RCIClient <b>is</b>
        B : Integer;
        C : Customer_Type := "rich";
        P : Password_Type := "xxxx";
     <b>begin</b>
        B := Balance (C, P);
     <b>end</b> RCIClient;
     
</pre>
   <div class="node">
<p><hr>
<a name="Remote-Access-to-Subprograms-_0028RAS_0029"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Remote-Access-to-Class-Wide-Types-_0028RACW_0029">Remote Access to Class Wide Types (RACW)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Regular-Remote-Subprograms-_0028RCI_0029">Regular Remote Subprograms (RCI)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>
<br>
</div>

<h4 class="subsection">2.4.3 Remote Access to Subprograms (RAS)</h4>

<p>In the following example, several mirroring banks offer their services
through the same database. Each bank registers a reference to each of
its services with a central bank. A client of the central bank requests
a service from one of the mirroring banks. To satisfy requests, the RCI
unit RASBank defines Balance_Type, a remote access to subprogram (Recall
that an access type declared in a remote unit has to be either remote
access to subprogram or remote access to class wide type).

   <p>Note that to obtain a remote access to subprogram, the subprogram that
delivers the remote access must be remote itself. Therefore, MirrorBank
is a RCI library unit.

<pre class="smallexample">     
     <b>with</b> Types; <b>use</b> Types;
     <b>package</b> RASBank <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>type</b> Balance_Type <b>is</b> <b>access</b> <b>function</b>
          (Customer : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type)
           <b>return</b> Integer;
     
        <b>procedure</b> Register
           (Balance : <b>in</b> Balance_Type);
     
        <b>function</b> Get_Balance
           <b>return</b> Balance_Type;
     
        --  [...] Other services
     <b>end</b> RASBank;
     
</pre>
   <p>In the code below, a mirroring bank registers its services to the
central bank.

<pre class="smallexample">     
     <b>with</b> Types; <b>use</b> Types;
     <b>package</b> MirrorBank <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>function</b> Balance
          (Customer : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type)
           <b>return</b> Integer;
     
        --  [...] Other services
     <b>end</b> MirrorBank;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> RASBank, Types; <b>use</b> RASBank, Types;
     <b>package</b> <b>body</b> MirrorBank <b>is</b>
     
        <b>function</b> Balance
          (Customer : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type)
           <b>return</b> Integer <b>is</b>
        <b>begin</b>
           <b>return</b> Something;
        <b>end</b> Balance;
     
     <b>begin</b>
        --  Register a dynamically bound <b>rem</b>ote subprogram (Balance)
        --  through a statically bound <b>rem</b>ote subprogram (Register)
        Register (Balance'Access);
        --  [...] Register other services
     <b>end</b> MirrorBank;
     
</pre>
   <p>In the code below, a central bank client asks for a mirroring bank and
calls the Balance service of this bank by dereferencing a remote access
type.

<pre class="smallexample">     
     <b>with</b> Types; <b>use</b> Types;
     <b>with</b> RASBank; <b>use</b> RASBank;
     <b>procedure</b> BankClient <b>is</b>
        B : Integer;
        C : Customer_Type := "rich";
        P : Password_Type := "xxxx";
     <b>begin</b>
        --  Through a statically bound <b>rem</b>ote subprogram (Get_Balance), get
        --  a dynamically bound <b>rem</b>ote subprogram. Dereference it to
        --  perform a dynamic <b>in</b>vocation.
        B := Get_Balance.<b>all</b> (C, P);
     <b>end</b> BankClient;
     
</pre>
   <div class="node">
<p><hr>
<a name="Remote-Access-to-Class-Wide-Types-_0028RACW_0029"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Summary-on-Pragma-Remote_005fCall_005fInterface">Summary on Pragma Remote_Call_Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Remote-Access-to-Subprograms-_0028RAS_0029">Remote Access to Subprograms (RAS)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>
<br>
</div>

<h4 class="subsection">2.4.4 Remote Access to Class Wide Types (RACW)</h4>

<p>A bank client is now connected to a bank through a terminal. The bank
wants to notify a connected client, bu means of a message on its
terminal, when another client transfers a given amount of money to his
account. In the following example, a terminal is designed as a
distributed object. Each bank client will register its terminal object
to the bank server for further use. In the code below, Term_Type is the
root type of the distributed terminal hierarchy.

<pre class="smallexample">     
     <b>with</b> Types; <b>use</b> Types;
     <b>package</b> Terminal <b>is</b>
        <b>pragma</b> Pure;
     
        <b>type</b> Term_Type <b>is</b> <b>abstract</b> <b>tagged</b> <b>limited</b> <b>private</b>;
     
        <b>procedure</b> Notify
          (MyTerm   : <b>access</b> Term_Type;
           Payer    : <b>in</b> Customer_Type;
           Amount   : <b>in</b> Integer) <b>is</b> <b>abstract</b>;
     
     <b>private</b>
        <b>type</b> Term_Type <b>is</b> <b>abstract</b> <b>tagged</b> <b>limited</b> <b>null</b> <b>record</b>;
     <b>end</b> Terminal;
     
</pre>
   <p>In the code below, the RCI unit RACWBank defines Term_Access, a remote
access to class wide type. Term_Access becomes a reference to a
distributed object. In the next section, we will see how to derive and
extend Term_Type, how to create a distributed object and how to use a
reference to it.

<pre class="smallexample">     
     <b>with</b> Terminal, Types; <b>use</b> Terminal, Types;
     <b>package</b> RACWBank <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>type</b> Term_Access <b>is</b> <b>access</b> <b>all</b> Term_Type'Class;
     
        <b>procedure</b> Register
          (MyTerm   : <b>in</b> Term_Access;
           Customer : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type);
     
        --  [...] Other services
     <b>end</b> RACWBank;
     
</pre>
   <div class="node">
<p><hr>
<a name="Summary-on-Pragma-Remote_005fCall_005fInterface"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Remote-Access-to-Class-Wide-Types-_0028RACW_0029">Remote Access to Class Wide Types (RACW)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>
<br>
</div>

<h4 class="subsection">2.4.5 Summary on Pragma Remote_Call_Interface</h4>

<p>Remote call interface units:

     <ul>
<li>Allow subprograms to be called and executed remotely

     <li>Allow statically bound remote calls (remote subprogram)

     <li>Allow dynamically bound remote calls (remote access types)

     <li>Forbid variables and non-remote access types

     <li>Prevent specification from depending on normal units

   </ul>

<div class="node">
<p><hr>
<a name="Pragma-Remote_005fTypes"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Shared_005fPassive">Pragma Shared_Passive</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Remote_005fCall_005fInterface">Pragma Remote_Call_Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.5 Pragma Remote_Types</h3>

<ul class="menu">
<li><a accesskey="1" href="#Overview-of-Pragma-Remote_005fTypes">Overview of Pragma Remote_Types</a>
<li><a accesskey="2" href="#Distributed-Object">Distributed Object</a>
<li><a accesskey="3" href="#Transmitting-Dynamic-Structure">Transmitting Dynamic Structure</a>
<li><a accesskey="4" href="#Summary-on-Remote-Types-Units">Summary on Remote Types Units</a>
</ul>

<div class="node">
<p><hr>
<a name="Overview-of-Pragma-Remote_005fTypes"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Distributed-Object">Distributed Object</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>
<br>
</div>

<h4 class="subsection">2.5.1 Overview of Pragma Remote_Types</h4>

<p>Unlike RCI units, library units categorized with this pragma can define
distributed objects and remote methods on them. Both RCI and RT units
can define a remote access type as described above (RACW). A subprogram
defined in a RT unit is not a remote subprogram. Unlike RCI units, a RT
unit can be duplicated on several partitions in which case all its
entities are different with each other. This unit is different on each
partition in which it is defined.

<div class="node">
<p><hr>
<a name="Distributed-Object"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Transmitting-Dynamic-Structure">Transmitting Dynamic Structure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview-of-Pragma-Remote_005fTypes">Overview of Pragma Remote_Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>
<br>
</div>

<h4 class="subsection">2.5.2 Distributed Object</h4>

<p>If we want to implement the notification feature proposed in the
previous section, we have to derive Term_Type. Such a derivation is
possible in a remote types unit like NewTerminal (see below). Any object
of type New_Term_Type becomes a distributed object and any reference to
such an object becomes a fat pointer or a reference to a distributed
object (see Term_Access declaration in <a href="#Remote-Access-to-Class-Wide-Types-_0028RACW_0029">Remote Access to Class Wide Types (RACW)</a>).

<pre class="smallexample">     
     <b>with</b> Types, Terminal; <b>use</b> Types, Terminal;
     <b>package</b> NewTerminal <b>is</b>
        <b>pragma</b> Remote_Types;
     
        <b>type</b> New_Term_Type <b>is</b>
           <b>new</b> Term_Type <b>with</b> <b>null</b> <b>record</b>;
     
        <b>procedure</b> Notify
          (MyTerm   : <b>access</b> New_Term_Type;
           Payer    : <b>in</b> Customer_Type;
           Amount   : <b>in</b> Integer);
     
        <b>function</b> Current <b>return</b> Term_Access;
     <b>end</b> NewTerminal;
     
</pre>
   <p>In the code below, a client registers his name and his terminal with
RACWBank. Therefore, when any payer transfers some money to him,
RACWBank is able to notify the client of the transfer of funds.

<pre class="smallexample">     
     <b>with</b> NewTerminal, RACWBank, Types; <b>use</b> NewTerminal, RACWBank, Types;
     <b>procedure</b> Term1Client <b>is</b>
        MyTerm   : Term_Access   := Current;
        Customer : Customer_Type := "poor";
        Password : Password_Type := "yyyy";
     <b>begin</b>
        Register (MyTerm, Customer, Password);
        --  [...] Execute other things
     <b>end</b> Term1Client;
     
</pre>
   <p>In the code below, a second client, the payer, registers his terminal
to the bank and executes a transfer to the first client.

<pre class="smallexample">     
     <b>with</b> NewTerminal, RACWBank, Types; <b>use</b> NewTerminal, RACWBank, Types;
     <b>procedure</b> Term2Client <b>is</b>
        MyTerm   : Term_Access   := Current;
        Payer    : Customer_Type := "rich";
        Password : Password_Type := "xxxx";
        Payee    : Customer_Type := "poor";
     <b>begin</b>
        Register (MyTerm, Payer, Password);
        Transfer (Payer, Password, 100, Payee);
     <b>end</b> Term2Client;
     
</pre>
   <p>In the code below, we describe the general design of Transfer. Classical
operations of Withdraw and Deposit are performed. Then, RACWBank
retrieves the terminal of the payee (if present) and invokes a
dispatching operation by dereferencing a distributed object Term. The
reference is examined at run-time, and the execution of this operation
takes place on the partition on which the distributed object resides.

<pre class="smallexample">     
     <b>with</b> Types; <b>use</b> Types;
     <b>package</b> <b>body</b> RACWBank <b>is</b>
        <b>procedure</b> Register
          (MyTerm   : <b>in</b> Term_Access;
           Customer : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type) <b>is</b>
        <b>begin</b>
           Insert_In_Local_Table (MyTerm, Customer);
        <b>end</b> Register;
     
        <b>procedure</b> Transfer
          (Payer    : <b>in</b> Customer_Type;
           Password : <b>in</b> Password_Type;
           Amount   : <b>in</b> Positive;
           Payee    : <b>in</b> Customer_Type)
        <b>is</b>
           --  Find Customer terminal.
           Term : Term_Access
             := Find_In_Local_Table (Payee);
        <b>begin</b>
           Withdraw (Payer, Amount);
           Deposit  (Payee, Amount);
           <b>if</b> Term /= <b>null</b> <b>then</b>
              --  Notify on Payee terminal.
              Notify (Term, Payer, Amount);
           <b>end</b> <b>if</b>;
        <b>end</b> Transfer;
     
        --  [...] Other services
     <b>end</b> RACWBank;
     
</pre>
   <div class="node">
<p><hr>
<a name="Transmitting-Dynamic-Structure"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Summary-on-Remote-Types-Units">Summary on Remote Types Units</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Distributed-Object">Distributed Object</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>
<br>
</div>

<h4 class="subsection">2.5.3 Transmitting Dynamic Structure</h4>

<pre class="smallexample">     
     <b>with</b> Ada.Streams; <b>use</b> Ada.Streams;
     <b>package</b> StringArrayStream <b>is</b>
        <b>pragma</b> Remote_Types;
     
        <b>type</b> List <b>is</b> <b>private</b>;
        <b>procedure</b> Append (L : <b>access</b> List; O : <b>in</b> String);
        <b>function</b>  Delete (L : <b>access</b> List) <b>return</b> String;
     
     <b>private</b>
        <b>type</b> String_Access <b>is</b> <b>access</b> String;
     
        <b>type</b> Node;
        <b>type</b> List <b>is</b> <b>access</b> Node;
     
        <b>type</b> Node <b>is</b> <b>record</b>
           Content : String_Access;
           Next    : List;
        <b>end</b> <b>record</b>;
     
        <b>procedure</b> Read
          (S : <b>access</b> Root_Stream_Type'Class;
           L : <b>out</b> List);
        <b>procedure</b> Write
          (S : <b>access</b> Root_Stream_Type'Class;
           L : <b>in</b> List);
        <b>for</b> List'Read <b>use</b> Read;
        <b>for</b> List'Write <b>use</b> Write;
     <b>end</b> StringArrayStream;
     
</pre>
   <p>Non-remote access types cannot be declared in the public part of a
remote types unit. However, it is possible to define private non-remote
access types as long as the user provides its marshaling procedures,
that is to say the mechanism needed to place a value of the type into a
communication stream.  The code below describes how to transmit a linked
structure.

   <p>The package declaration provides a type definition of single-linked
lists of unbounded strings. An implementation of the marshaling
operations could be the following:

<pre class="smallexample">     
     <b>package</b> <b>body</b> StringArrayStream <b>is</b>
        <b>procedure</b> Read
          (S : <b>access</b> Root_Stream_Type'Class;
           L : <b>out</b> List) <b>is</b>
        <b>begin</b>
           <b>if</b> Boolean'Input (S) <b>then</b>
              L := <b>new</b> Node;
              L.Content := <b>new</b> String'(String'Input (S));
              List'Read (S, L.Next);
           <b>else</b>
              L := <b>null</b>;
           <b>end</b> <b>if</b>;
        <b>end</b> Read;
     
        <b>procedure</b> Write
          (S : <b>access</b> Root_Stream_Type'Class;
           L : <b>in</b> List) <b>is</b>
        <b>begin</b>
           <b>if</b> L = <b>null</b> <b>then</b>
              Boolean'Output (S, False);
           <b>else</b>
              Boolean'Output (S, True);
              String'Output (S, L.Content.<b>all</b>);
              List'Write (S, L.Next);
           <b>end</b> <b>if</b>;
        <b>end</b> Write;
     
        --  [...] Other services
     <b>end</b> StringArrayStream;
     
</pre>
   <div class="node">
<p><hr>
<a name="Summary-on-Remote-Types-Units"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Transmitting-Dynamic-Structure">Transmitting Dynamic Structure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>
<br>
</div>

<h4 class="subsection">2.5.4 Summary on Remote Types Units</h4>

<p>Remote types units:

     <ul>
<li>Support the definition of distributed objects

     <li>Allow dynamically bound remote calls (via remote access types)

     <li>Allow non-remote access type (with marshaling subprograms)

     <li>Cannot have a specification that depends on normal units

   </ul>

<div class="node">
<p><hr>
<a name="Pragma-Shared_005fPassive"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Remote_005fTypes">Pragma Remote_Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.6 Pragma Shared_Passive</h3>

<ul class="menu">
<li><a accesskey="1" href="#Overview-of-Pragma-Shared_005fPassive">Overview of Pragma Shared_Passive</a>
<li><a accesskey="2" href="#Summary-on-Pragma-Shared_005fPassive">Summary on Pragma Shared_Passive</a>
</ul>

<div class="node">
<p><hr>
<a name="Overview-of-Pragma-Shared_005fPassive"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Summary-on-Pragma-Shared_005fPassive">Summary on Pragma Shared_Passive</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Shared_005fPassive">Pragma Shared_Passive</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Shared_005fPassive">Pragma Shared_Passive</a>
<br>
</div>

<h4 class="subsection">2.6.1 Overview of Pragma Shared_Passive</h4>

<p>The entities declared in such a categorized library unit are intended to
be mapped on a virtual shared address space (file, memory,
database). When two partitions use such a library unit, they can
communicate by reading or writing the same variable in the shared
unit. This supports the conventional shared variables paradigm. 
Entryless protected objects can be declared in these units, to provide
an atomic access to shared data, thus implementing a simple transaction
mechanism. When the address space is a file or a database, the user can
take advantage of the persistency features provided by these storage
nodes.

<h4 class="subsection">2.6.2 Shared and Protected Objects</h4>

<p>In the code below, we define two kinds of shared
objects. External_Synchronization requires that the different partitions
updating this data synchronize to avoid conflicting operations on shared
objects. Internal_Synchronization provides a way to get an atomic
operation on shared objects. Note that only entry-less subprograms are
allowed in a shared passive unit.

<pre class="smallexample">     
     <b>package</b> SharedObjects <b>is</b>
        <b>pragma</b> Shared_Passive;
     
        Max : Positive := 10;
        <b>type</b> Index_Type <b>is</b> <b>range</b> 1 .. Max;
        <b>type</b> Rate_Type <b>is</b> <b>new</b> Float;
     
        <b>type</b> Rates_Type <b>is</b> <b>array</b> (Index_Type) <b>of</b> Rate_Type;
     
        External_Synchronization : Rates_Type;
     
        <b>protected</b> Internal_Synchronization <b>is</b>
           <b>procedure</b> Set
             (Index : <b>in</b> Index_Type;
              Rate  : <b>in</b> Rate_Type);
     
           <b>procedure</b> Get
             (Index : <b>in</b> Index_Type;
              Rate  : <b>out</b> Rate_Type);
        <b>private</b>
           Rates : Rates_Type;
        <b>end</b> Internal_Synchronization;
     <b>end</b> SharedObjects;
     
</pre>
   <div class="node">
<p><hr>
<a name="Summary-on-Pragma-Shared_005fPassive"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview-of-Pragma-Shared_005fPassive">Overview of Pragma Shared_Passive</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pragma-Shared_005fPassive">Pragma Shared_Passive</a>
<br>
</div>

<h4 class="subsection">2.6.3 Summary on Pragma Shared_Passive</h4>

     <ul>
<li>Allow direct access to data from different partitions

     <li>Provide support for shared (distributed) memory

     <li>Support memory protection by means of entryless protected objects

     <li>Prevent specification from depending on normal units

</ul>

<div class="node">
<p><hr>
<a name="More-About-Categorization-Pragmas"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Shared_005fPassive">Pragma Shared_Passive</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.7 More About Categorization Pragmas</h3>

<ul class="menu">
<li><a accesskey="1" href="#Variables-and-Non_002dRemote-Access-Types">Variables and Non-Remote Access Types</a>
<li><a accesskey="2" href="#RPC-Failures">RPC Failures</a>
<li><a accesskey="3" href="#Exceptions">Exceptions</a>
<li><a accesskey="4" href="#Pragma-Asynchronous">Pragma Asynchronous</a>
<li><a accesskey="5" href="#Pragma-All_005fCalls_005fRemote">Pragma All_Calls_Remote</a>
<li><a accesskey="6" href="#Generic-Categorized-Units">Generic Categorized Units </a>
<li><a accesskey="7" href="#Categorization-Unit-Dependencies">Categorization Unit Dependencies</a>
</ul>

<div class="node">
<p><hr>
<a name="Variables-and-Non_002dRemote-Access-Types"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#RPC-Failures">RPC Failures</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<br>
</div>

<h4 class="subsection">2.7.1 Variables and Non-Remote Access Types</h4>

<p>In RT or RCI package declarations, variable declarations are forbidden,
and non-remote access types are allowed as long as their marshaling
subprograms are explicitly provided (see <a href="#Transmitting-Dynamic-Structure">Transmitting Dynamic Structure</a>)..

<div class="node">
<p><hr>
<a name="RPC-Failures"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Exceptions">Exceptions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables-and-Non_002dRemote-Access-Types">Variables and Non-Remote Access Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<br>
</div>

<h4 class="subsection">2.7.2 RPC Failures</h4>

<p>Calls are executed at most once: they are made exactly one time or they
fail with an exception. When a communication error occurs,
<i>System.RPC.Communication_Error</i> is raised.

<div class="node">
<p><hr>
<a name="Exceptions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Asynchronous">Pragma Asynchronous</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#RPC-Failures">RPC Failures</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<br>
</div>

<h4 class="subsection">2.7.3 Exceptions</h4>

<p>Any exception raised in a remote method or subprogram call is propagated
back to the caller. Exceptions semantics are preserved in the regular
Ada way.

<pre class="smallexample">     
     <b>package</b> Internal <b>is</b>
        Exc : <b>exception</b>;
     <b>end</b> Internal;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> RemPkg2 <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> Subprogram;
     <b>end</b> RemPkg2;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> RemPkg1 <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> Subprogram;
     <b>end</b> RemPkg1;
     
</pre>
   <p>Let us say that RemPkg2, Internal and RemExcMain packages are on the same
partition Partition_1 and that RemPkg1 is on partition Partition_2.

<pre class="smallexample">     
     <b>with</b> RemPkg1, Ada.Exceptions; <b>use</b> Ada.Exceptions;
     <b>package</b> <b>body</b> RemPkg2 <b>is</b>
        <b>procedure</b> Subprogram <b>is</b>
        <b>begin</b>
           RemPkg1.Subprogram;
        <b>exception</b> <b>when</b> E : <b>others</b> =&gt;
           Raise_Exception (Exception_Identity (E), Exception_Message (E));
        <b>end</b> Subprogram;
     <b>end</b> RemPkg2;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> Internal, Ada.Exceptions; <b>use</b> Ada.Exceptions;
     <b>package</b> <b>body</b> RemPkg1 <b>is</b>
        <b>procedure</b> Subprogram <b>is</b>
        <b>begin</b>
           Raise_Exception (Internal.Exc'Identity, "Message");
        <b>end</b> Subprogram;
     <b>end</b> RemPkg1;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> Ada.Text_IO, Ada.Exceptions; <b>use</b> Ada.Text_IO, Ada.Exceptions;
     <b>with</b> RemPkg2, Internal;
     <b>procedure</b> RemExcMain <b>is</b>
     <b>begin</b>
        RemPkg2.Subprogram;
     <b>exception</b> <b>when</b> E : Internal.Exc =&gt;
        Put_Line (Exception_Message (E)); -- Output "Message"
     <b>end</b> RemExcMain;
     
</pre>
   <p>When RemPkg1.Subprogram on Partition_1 raises Internal.Exc, this
exception is propagated back to Partition_2. As Internal.Exc is not
defined on Partition_2, it is not possible to catch this exception
without an exception handler <b>when others</b>. When this exception is
reraised in RemPkg1.Subprogram, it is propagated to Partition_1. But
this time, Internal.Exc is visible and can be handled as we would in a
single-partition Ada program. Of course, the exception message is also
preserved.

<!-- XXXX Schema Sam exceptions -->
<div class="node">
<p><hr>
<a name="Pragma-Asynchronous"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-All_005fCalls_005fRemote">Pragma All_Calls_Remote</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Exceptions">Exceptions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<br>
</div>

<h4 class="subsection">2.7.4 Pragma Asynchronous</h4>

<p>By default, a remote call is blocking: the caller waits until the remote
call is complete and the output stream is received. By contrast.  a
remote subprogram labeled with pragma Asynchronous allows statically
and dynamically bound remote calls to it to be executed
asynchronously. A call to an asynchronous procedure doesn't wait for the
completion of the remote call, and lets the caller continue its
execution. The remote procedure must have only <b>in</b> parameters, and
any exception raised during the execution of the remote procedure is
lost.

   <p>When pragma Asynchronous applies to a regular subprogram with <b>in</b>
parameters, any call to this subprogram will be executed
asynchronously. The following declaration of
AsynchronousRCI.Asynchronous gives an example.

<pre class="smallexample">     
     <b>package</b> AsynchronousRCI <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> Asynchronous (X : Integer);
        <b>pragma</b> Asynchronous (Asynchronous);
     
        <b>procedure</b> Synchronous  (X : Integer);
     
        <b>type</b> AsynchronousRAS <b>is</b> <b>access</b> <b>procedure</b> (X : Integer);
        <b>pragma</b> Asynchronous (AsynchronousRAS);
     <b>end</b> AsynchronousRCI;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> AsynchronousRT <b>is</b>
        <b>pragma</b> Remote_Types;
     
        <b>type</b> Object <b>is</b> <b>tagged</b> <b>limited</b> <b>private</b>;
     
        <b>type</b> AsynchronousRACW <b>is</b> <b>access</b> <b>all</b> Object'Class;
        <b>pragma</b> Asynchronous (AsynchronousRACW);
     
        <b>procedure</b> Asynchronous (X : Object);
        <b>procedure</b> Synchronous  (X : <b>in</b> <b>out</b> Object);
        <b>function</b> Create <b>return</b> AsynchronousRACW;
     
     <b>private</b>
        <b>type</b> Object <b>is</b> <b>tagged</b> <b>limited</b> <b>null</b> <b>record</b>;
     <b>end</b> AsynchronousRT;
     
</pre>
   <p>A pragma Asynchronous applies to a Remote Access_to_Subprogram (RAS). 
An asynchronous RAS can be both asynchronous and synchronous depending
on the designated subprogram. For instance, in the code below, remote
call (1) is asynchronous but remote call (2) is synchronous.

   <p>A pragma Asynchronous applies to a RACW as well. In this case, the
invocation of <b>any</b> method with in parameters is <b>always</b> performed
asynchronously. Remote method invocation (3) is asynchronous but remote
method invocation (4) is synchronous.

<pre class="smallexample">     
     <b>with</b> AsynchronousRCI, AsynchronousRT;
     <b>use</b> AsynchronousRCI, AsynchronousRT;
     <b>procedure</b> AsynchronousMain <b>is</b>
        RAS  : AsynchronousRAS;
        RACW : AsynchronousRACW := Create;
     <b>begin</b>
        --  Asynchronous Dynamically Bound Remote Call (1)
        RAS := AsynchronousRCI.Asynchronous'Access;
        RAS (0);  --  Abbrev <b>for</b> RAS.<b>all</b> (0)
        --  Synchronous Dynamically Bound Remote Call (2)
        RAS := AsynchronousRCI.Synchronous'Access;
        RAS (0);
        --  Asynchronous Dynamically Bound Remote Call (3)
        Asynchronous (RACW.<b>all</b>);
        --  Synchronous Dynamically Bound Remote Call (4)
        Synchronous (RACW.<b>all</b>);
     <b>end</b> AsynchronousMain;
     
</pre>
   <p>This feature supports the conventional message passing paradigm. The
user must be aware that this paradigm, and asynchronous remote calls in
particular, has several drawbacks:

     <ul>
<li>It violates original (remote) procedure semantics

     <li>It allows the equivalent of a remote GOTO mechanism

     <li>It prevents easy development and debugging in a non-distributed context

     <li>It can introduce potential race conditions

   </ul>

   <p>To illustrate the latter, let us take the following example:

<pre class="smallexample">     
     <b>package</b> Node2 <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> Send (X : Integer);
        <b>pragma</b> Asynchronous (Send);
     <b>end</b> Node2;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> <b>body</b> Node2 <b>is</b>
        V : Integer := 0;
        <b>procedure</b> Send (X : Integer) <b>is</b>
        <b>begin</b>
           V := X;
        <b>end</b> Send;
     <b>end</b> Node2;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> Node1 <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> Send (X : Integer);
        <b>pragma</b> Asynchronous (Send);
     <b>end</b> Node1;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> Node2;
     <b>package</b> <b>body</b> Node1 <b>is</b>
        <b>procedure</b> Send (X : Integer) <b>is</b>
        <b>begin</b>
           Node2.Send (X);
        <b>end</b> Send;
     <b>end</b> Node1;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> Node1, Node2;
     <b>procedure</b> NonDeterministic <b>is</b>
     <b>begin</b>
        Node1.Send (1);
        Node2.Send (2);
     <b>end</b> NonDeterministic;
     
</pre>
   <p>Let us say that Main is configured on Partition_0, Node1 on Partition_1
and Node2 on Partition_2. If Node1.Send and Node2.Send procedures were
synchronous or if no latency was introduced during network
communication, we would have the following RPC order: Main remotely
calls Node1.Send which remotely calls Node2.Send which sets V to
1. Then, Main remotely calls Node2.Send and sets V to 2.

   <p>Now, let us assume that both Send procedures are asynchronous and that
the connection between Partition_1 and Partition_2 is very slow. The
following scenario can very well occur. Main remotely calls Node1.Send
and is unblocked. Immediately after this call, Main remotely calls
Node2.Send and sets V to 2. Once this is done, the remote call to
Node1.Send completes on Partition_1 and it remotely calls Node2.Send
which sets V to 1.

<div class="node">
<p><hr>
<a name="Pragma-All_005fCalls_005fRemote"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Generic-Categorized-Units">Generic Categorized Units</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Asynchronous">Pragma Asynchronous</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<br>
</div>

<h4 class="subsection">2.7.5 Pragma All_Calls_Remote</h4>

<p>A pragma All_Calls_Remote in a RCI unit forces remote procedure
calls to be routed through the communication subsystem even for a local
call. This eases the debugging of an application in a non-distributed
situation that is very close to the distributed one, because the communication
subsystem (including marshaling and unmarshaling procedures) can be
exercised on a single node.

   <p>In some circumstances, a non-distributed application can behave
differently than an application distributed on only one partition. This
can happen when both All_Calls_Remote and Asynchronous features are used
at the same time (see <a href="#Pragma-Asynchronous">Pragma Asynchronous</a> for an example). Another
circumstance occur when the marshaling operations raise an
exception. In the following example, when unit ACRRCI is a
All_Calls_Remote package, the program raises Program_Error. When
unit ACRRCI is no longer a All_Calls_Remote package, then the program
completes silently.

<pre class="smallexample">     
     <b>with</b> Ada.Streams; <b>use</b> Ada.Streams;
     <b>package</b> ACRRT <b>is</b>
        <b>pragma</b> Remote_Types;
        <b>type</b> T <b>is</b> <b>private</b>;
     <b>private</b>
        <b>type</b> T <b>is</b> <b>new</b> Integer;
        <b>procedure</b> Read
          (S : <b>access</b> Root_Stream_Type'Class;
           X : <b>out</b> T);
        <b>procedure</b> Write
          (S : <b>access</b> Root_Stream_Type'Class;
           X : <b>in</b> T);
        <b>for</b> T'Read  <b>use</b> Read;
        <b>for</b> T'Write <b>use</b> Write;
     <b>end</b> ACRRT;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> <b>body</b> ACRRT <b>is</b>
        <b>procedure</b> Read
          (S : <b>access</b> Root_Stream_Type'Class;
           X : <b>out</b> T) <b>is</b>
        <b>begin</b>
           <b>raise</b> Program_Error;
        <b>end</b> Read;
     
        <b>procedure</b> Write
          (S : <b>access</b> Root_Stream_Type'Class;
           X : <b>in</b> T) <b>is</b>
        <b>begin</b>
           <b>raise</b> Program_Error;
        <b>end</b> Write;
     <b>end</b> ACRRT;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> ACRRT; <b>use</b> ACRRT;
     <b>package</b> ACRRCI <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
        <b>pragma</b> All_Calls_Remote;
     
        <b>procedure</b> P (X : T);
     <b>end</b> ACRRCI;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> <b>body</b> ACRRCI <b>is</b>
        <b>procedure</b> P (X : T) <b>is</b>
        <b>begin</b>
           <b>null</b>;
        <b>end</b> P;
     <b>end</b> ACRRCI;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> ACRRCI, ACRRT;
     <b>procedure</b> ACRMain <b>is</b>
        X : ACRRT.T;
     <b>begin</b>
        ACRRCI.P (X);
     <b>end</b> ACRMain;
     
</pre>
   <div class="node">
<p><hr>
<a name="Generic-Categorized-Units"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Categorization-Unit-Dependencies">Categorization Unit Dependencies</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-All_005fCalls_005fRemote">Pragma All_Calls_Remote</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<br>
</div>

<h4 class="subsection">2.7.6 Generic Categorized Units</h4>

<pre class="smallexample">     
     <b>generic</b>
     <b>package</b> GenericRCI <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> P;
     <b>end</b> GenericRCI;
     
</pre>
<pre class="smallexample">     
     <b>with</b> GenericRCI;
     <b>package</b> RCIInstantiation <b>is</b> <b>new</b> GenericRCI;
     <b>pragma</b> Remote_Call_Interface (RCIInstantiation);
     
</pre>
   <pre class="smallexample">     
     <b>with</b> GenericRCI;
     <b>package</b> NormalInstantiation <b>is</b> <b>new</b> GenericRCI;
     
</pre>
   <p>Any of these categorized units can be generic. Instances do not
automatically inherit the categorization of their generic units, and
they can be categorized explicitly, If they are not, instances are
normal compilation units.  Like any other categorized unit, a
categorized instance must be at the library level, and regular
restrictions of categorized units apply on instantiation (in particular
on generic formal parameters).

<div class="node">
<p><hr>
<a name="Categorization-Unit-Dependencies"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Generic-Categorized-Units">Generic Categorized Units</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>
<br>
</div>

<h4 class="subsection">2.7.7 Categorization Unit Dependencies</h4>

<p>Each categorization pragma has very specific visibility rules. As a
general rule, RCI &gt; RT &gt; SP &gt; Pure, where the comparison indicates
allowed semantic dependencies. This means that a Remote_Types package
can make visible in its specification only Remote_Types, Shared_Passive
and Pure units.

<div class="node">
<p><hr>
<a name="Partition-Communication-Subsystem"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Most-Features-in-One-Example">Most Features in One Example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#More-About-Categorization-Pragmas">More About Categorization Pragmas</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.8 Partition Communication Subsystem</h3>

<ul class="menu">
<li><a accesskey="1" href="#Marshaling-and-Unmarshaling-Operations">Marshaling and Unmarshaling Operations</a>
<li><a accesskey="2" href="#Incorrect-Remote-Dispatching">Incorrect Remote Dispatching</a>
<li><a accesskey="3" href="#Partition-Ids">Partition Ids</a>
<li><a accesskey="4" href="#Concurrent-Remote-Calls">Concurrent Remote Calls</a>
<li><a accesskey="5" href="#Consistency-and-Elaboration">Consistency and Elaboration</a>
<li><a accesskey="6" href="#Abortion-and-Termination">Abortion and Termination</a>
</ul>

<div class="node">
<p><hr>
<a name="Marshaling-and-Unmarshaling-Operations"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Incorrect-Remote-Dispatching">Incorrect Remote Dispatching</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">2.8.1 Marshaling and Unmarshaling Operations</h4>

<p>The Partition Communication Subsystem  (PCS) is the runtime library for
distributed features. It marshals and unmarshals client and server requests
into a data stream suitable for network transmission.

<pre class="smallexample">     
     <b>type</b> Params_Stream_Type
       (Initial_Size : Ada.Streams.Stream_Element_Count) <b>is new</b>
         Ada.Streams.Root_Stream_Type <b>with private</b>;
</pre>
   <p>This type is a container for the data to be transmitted between
partitions. Its root is <i>Root_Stream_Type</i>, which defines the basic
stream type and two abstract operations, <i>Write</i> and <i>Read</i>. Its
purpose is to insert / remove objects of type <i>Stream_Element_Array</i>
which are array of bytes representing a particular data.

   <p>Streams are read and written using four attributes:

     <ul>
<li>Write: write an element into a stream, valid only for constrained
types

     <li>Read: read a constrained element from a stream

     <li>Output: same as Write, but write bounds and discriminants as well
if needed

     <li>Input: same as Read, but read bounds and discriminants from
  the stream (the Input attribute denotes a function)
</ul>

   <p>An Ada compiler provides default 'Read and 'Write operations. But it is
up to the implementation of the PCS to provide default 'Read and 'Write
to ensure proper operation between heterogeneous architectures (see
<a href="#Heterogeneous-System">Heterogeneous System</a>).

   <p>The user can overload these operations, except for predefined
types. Overloading with a textual version provides the user with a way
to debug its application (even outside of the Distributed Systems
Annex).

<pre class="smallexample">     
     <b>with</b> Ada.Streams; <b>use</b> Ada.Streams;
     <b>package</b> New_Integers <b>is</b>
        <b>pragma</b> Pure;
     
        <b>type</b> New_Integer <b>is</b> <b>new</b> Integer;
     
        <b>procedure</b> Read
          (S : <b>access</b> Root_Stream_Type'Class;
           V : <b>out</b> New_Integer);
        <b>procedure</b> Write
          (S : <b>access</b> Root_Stream_Type'Class;
           V : <b>in</b> New_Integer);
     
        <b>for</b> New_Integer'Read  <b>use</b> Read;
        <b>for</b> New_Integer'Write <b>use</b> Write;
     <b>end</b> New_Integers;
     
</pre>
   <pre class="smallexample">     
     <b>package</b> <b>body</b> New_Integers <b>is</b>
        <b>procedure</b> Read
          (S : <b>access</b> Root_Stream_Type'Class;
           V : <b>out</b> New_Integer)
        <b>is</b>
           B : String := String'Input (S);
        <b>begin</b>
           V := New_Integer'Value (B);
        <b>end</b> Read;
     
        <b>procedure</b> Write
          (S : <b>access</b> Root_Stream_Type'Class;
           V : <b>in</b> New_Integer)
        <b>is</b>
        <b>begin</b>
           String'Output (S, New_Integer'Image (V));
        <b>end</b> Write;
     <b>end</b> New_Integers;
     
</pre>
   <p>The language forces the user to provide read and write operations for
non-remote access types. Transmitting an access value by dumping its
content into a stream makes no sense when it is going to be transmitted
to another partition (different memory spaces). To transmit non-remote
access types see <a href="#Transmitting-Dynamic-Structure">Transmitting Dynamic Structure</a>.

<div class="node">
<p><hr>
<a name="Incorrect-Remote-Dispatching"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Ids">Partition Ids</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Marshaling-and-Unmarshaling-Operations">Marshaling and Unmarshaling Operations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">2.8.2 Incorrect Remote Dispatching</h4>

<p>When a remote subprogram takes a class wide argument, there is a risk of
using an object of a derived type that will not be clean enough to be
transmitted. For example, given a type called Root_Type, if a remote
procedure takes a Root_Type'Class as an argument, the user can call it
with an instance of Derived_Type that is Root_Type enriched with a field
of a task type. This will lead to a non-communicable type to be
transmitted between partitions.

   <p>To prevent this, paragraph E.4(18) of the reference manual explains that
any actual type used as parameter for a remote call whose formal type is
a class wide type must be declared in the visible part of a Pure or
Remote_Types package. This property also holds for remote functions
returning class wide types. To summarize, the actual type used should
have been eligible for being declared where the root type has been
declared. If a `bad' object is given to a remote subprogram,
<i>Program_Error</i> will be raised at the point of the call.

<div class="node">
<p><hr>
<a name="Partition-Ids"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Concurrent-Remote-Calls">Concurrent Remote Calls</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Incorrect-Remote-Dispatching">Incorrect Remote Dispatching</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">2.8.3 Partition Ids</h4>

<p>U'Partition_ID identifies the partition where the unit U has been
elaborated. For this purpose, the PCS provides an integer type
Partition_ID to uniquely designate a partition. Note that a Partition_ID
is represented as a universal integer, and has no meaning outside of the
PCS. The RM requires that two partitions of a distributed program have
different Partition_ID's at a given time. A Partition_ID may or may not
be assigned statically (at compile or link time). A Partition_ID may or
may not be related to the physical location of the partition.

   <p>Partition_ID's can be used to check whether a RCI package is configured locally.

<pre class="smallexample">     
     <b>with</b> RCI;
     <b>with</b> Ada.Text_IO;
     <b>procedure</b> Check_PID <b>is</b>
     <b>begin</b>
        <b>if</b> RCI'Partition_ID = Check_PID'Partition_ID <b>then</b>
           Ada.Text_IO.Put_Line ("<b>package</b> RCI <b>is</b> configured locally");
        <b>else</b>
           Ada.Text_IO.Put_Line ("<b>package</b> RCI <b>is</b> configured <b>rem</b>otely");
        <b>end</b> <b>if</b>;
     <b>end</b> Check_PID;
     
</pre>
   <div class="node">
<p><hr>
<a name="Concurrent-Remote-Calls"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Consistency-and-Elaboration">Consistency and Elaboration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Ids">Partition Ids</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">2.8.4 Concurrent Remote Calls</h4>

<p>It is not defined by the PCS specification whether one or more threads
of control should be available to process incoming messages and to wait
for their completion. But the PCS implementation is required to be
reentrant, thereby allowing concurrent calls on it to service concurrent
remote subprogram calls into the server partition.  This means that at
the implementation level the PCS manages a pool of helper tasks. This
(apart from performance) is invisible to the user.

<div class="node">
<p><hr>
<a name="Consistency-and-Elaboration"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Abortion-and-Termination">Abortion and Termination</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concurrent-Remote-Calls">Concurrent Remote Calls</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">2.8.5 Consistency and Elaboration</h4>

<p>A library unit is consistent if the same version of its declaration is
used in all units that reference it. This requirement applies as well to
a unit that is referenced in several partitions of a distributed
program.  If a shared passive or RCI library unit U is included in some
partition P, It is a bounded error to elaborate another partition P1 of
a distributed program that that depends on a different version of U.  As
a result of this error, Program_Error can be raised in one or both
partitions during elaboration.

   <p>U'Version yields a string that identifies the version of the unit
declaration and any unit declaration on which it depends. U'Version_Body
yields a string that identifies the version of the unit body. These
attributes are used by the PCS to verify the consistency of an
application.

   <p>After elaborating the library units, but prior to invoking the main
subprogram, the PCS checks the RCI unit versions, and then accept any
incoming RPC. To guarantee that it is safe to call receiving stubs, any
incoming RPC is kept pending until the partition completes its
elaboration.

<div class="node">
<p><hr>
<a name="Abortion-and-Termination"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Consistency-and-Elaboration">Consistency and Elaboration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">2.8.6 Abortion and Termination</h4>

<p>If a construct containing a remote call is aborted, the remote
subprogram call is cancelled. Whether the execution of the remote
subprogram is immediately aborted as a result of the cancellation is
implementation defined.

   <p>An active partition terminates when its environment task terminates. In
other terms, a partition cannot terminate before the Ada program itself
terminates. The standard termination mechanism applies, but can be
extended with extra rules (see <a href="#Partition-Attribute-Termination">Partition Attribute Termination</a> for
examples).

<div class="node">
<p><hr>
<a name="Most-Features-in-One-Example"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Communication-Subsystem">Partition Communication Subsystem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>
<br>
</div>

<h3 class="section">2.9 Most Features in One Example</h3>

<p>The example shown on the following figure highlights most of the
features of DSA. The system is based on a set of factories and workers
and a storage.  Each entity is a partition itself. A factory hires a
worker from a pool of workers (hire - 1) and assigns a job (query - 2)
to him. The worker performs the job and saves the result (reply - 3) in
a storage common to all the factories.  The worker notifies the factory
of the end of his job (notify - 4).

   <p><br>
<br>
<img src="full-ex.fig.jpg" alt="full-ex.fig.jpg">
<br>

   <p>When a worker has completed his job, the result must be saved in a
common storage. To do this, we define a protected area in SP package
Storage (see following code). An entry-less protected object ensures
atomic access to this area.

<pre class="smallexample">     
     <b>package</b> Storage <b>is</b>
        <b>pragma</b> Shared_Passive;
     
        <b>protected</b> Queue <b>is</b>
           <b>procedure</b> Insert (Q, R : Integer);
           <b>procedure</b> Remove
             (Q : <b>in</b> Integer;
              R : <b>out</b> Integer);
        <b>private</b>
           --  Other declarations
        <b>end</b> Queue;
     <b>end</b> Storage;
     
</pre>
   <p>Common is a Remote_Types package that defines most of the remote
services of the above system (see following code). First, we define a
way for the workers to signal the completion of his job. This callback
mechanism is implemented using RAS Notify.

<pre class="smallexample">     
     <b>with</b> Storage; <b>use</b> Storage;
     <b>package</b> Common <b>is</b>
        <b>pragma</b> Remote_Types;
     
        <b>type</b> Notify <b>is</b>
           <b>access</b> <b>procedure</b> (Q : Integer);
        <b>pragma</b> Asynchronous (Notify);
     
        <b>type</b> Worker <b>is</b>
           <b>abstract</b> <b>tagged</b> <b>limited</b> <b>private</b>;
        <b>procedure</b> Assign
          (W : <b>access</b> Worker;
           Q : <b>in</b> Integer;
           N : <b>in</b> Notify) <b>is</b> <b>abstract</b>;
     
        <b>type</b> Any_Worker <b>is</b>
           <b>access</b> <b>all</b> Worker'Class;
        <b>pragma</b> Asynchronous (Any_Worker);
     
     <b>private</b>
        <b>type</b> Worker <b>is</b> <b>abstract</b> <b>tagged</b> <b>limited</b> <b>null</b> <b>record</b>;
     <b>end</b> Common;
     
</pre>
   <p>We define an abstract tagged type Worker which is intended to be the
root type of the whole distributed objects hierarchy. Assign allows a
factory to specify a job to a worker and a way for the worker to signal
its employer the completion of this job. Any_Worker is a remote access
to class wide type (RACW). In other words, it is a reference to a
distributed object of any derived type from Worker class. Note that the
two remote access types (Any_Worker and Notify) are declared as
asynchronous. Therefore, any override of Assign will be executed
asynchronously. To be asynchronous, an object of type Notify has to be a
reference to an asynchronous procedure.

   <p>NewWorker is derived from type Worker and Assign is overridden.

<pre class="smallexample">     
     <b>with</b> Common, Storage; <b>use</b> Common, Storage;
     <b>package</b> NewWorkers <b>is</b>
        <b>pragma</b> Remote_Types;
     
        <b>type</b> NewWorker <b>is</b> <b>new</b> Worker <b>with</b> <b>private</b>;
     
        <b>procedure</b> Assign
          (W : <b>access</b> NewWorker;
           Q : Integer;
           N : Notify);
     <b>private</b>
        <b>type</b> NewWorker <b>is</b> <b>new</b> Worker <b>with</b> <b>record</b>
           NewField : Field_Type; --  [...] Other fields
        <b>end</b> <b>record</b>;
     <b>end</b> NewWorkers;
     
</pre>
   <p>The following code shows how to derive a second generation of workers
NewNewWorker from the first generation NewWorker. As mentioned above,
this RT package can be duplicated on several partitions to produce
several types of workers and also several remote workers.

<pre class="smallexample">     
     <b>with</b> Common, Storage, NewWorkers; <b>use</b> Common, Storage, NewWorkers;
     <b>package</b> NewNewWorkers <b>is</b>
        <b>pragma</b> Remote_Types;
     
        <b>type</b> NewNewWorker <b>is</b> <b>new</b> NewWorker <b>with</b> <b>private</b>;
     
        <b>procedure</b> Assign
          (W : <b>access</b> NewNewWorker;
           Q : Integer;
           N : Notify);
     <b>private</b>
        <b>type</b> NewNewWorker <b>is</b> <b>new</b> NewWorker <b>with</b> <b>record</b>
           NewField : Field_Type; --  [...] Other fields
        <b>end</b> <b>record</b>;
     <b>end</b> NewNewWorkers;
     
</pre>
   <p>In the following code, we define a unique place where workers wait for
jobs. WorkerCity is a Remote_Call_Interface package with services to
hire and free workers. Unlike Remote_Types packages,
Remote_Call_Interface packages cannot be duplicated, and are assigned to
one specific partition.

<pre class="smallexample">     
     <b>with</b> Common; <b>use</b> Common;
     <b>package</b> WorkerCity <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> Insert (W : <b>in</b>  Any_Worker);
        <b>procedure</b> Remove (W : <b>out</b> Any_Worker);
     <b>end</b> WorkerCity;
     
</pre>
   <p>In order to use even more DSA features, Factory is defined as a generic
RCI package (see sample above). Any instantiation defines a new factory
(see sample above). To be RCI, this instantiation has to be categorized
once again.

<pre class="smallexample">     
     <b>with</b> Storage; <b>use</b> Storage;
     <b>generic</b>
     <b>package</b> Factory <b>is</b>
        <b>pragma</b> Remote_Call_Interface;
     
        <b>procedure</b> Notify (Q : Integer);
        <b>pragma</b> Asynchronous (Notify);
     <b>end</b> Factory;
     
</pre>
   <pre class="smallexample">     
     <b>with</b> Factory;
     <b>package</b> NewFactory <b>is</b> <b>new</b> Factory;
     <b>pragma</b> Remote_Call_Interface (NewFactory);
     
</pre>
   <div class="node">
<p><hr>
<a name="Getting-Started-With-GLADE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#DSA-and-CORBA">DSA and CORBA</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Distributed-Systems-Annex">The Distributed Systems Annex</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">3 Getting Started With GLADE</h2>

<p>This chapter describes the usual ways of using GLADE to compile Ada
distributed programs.

<ul class="menu">
<li><a accesskey="1" href="#Introduction-to-GLADE">Introduction to GLADE</a>
<li><a accesskey="2" href="#How-to-Configure-a-Distributed-Application">How to Configure a Distributed Application</a>
<li><a accesskey="3" href="#Gnatdist-Command-Line-Options">Gnatdist Command Line Options</a>
<li><a accesskey="4" href="#Gnatdist-Behind-the-Scenes">Gnatdist Behind the Scenes</a>
<li><a accesskey="5" href="#The-Configuration-Language">The Configuration Language</a>
<li><a accesskey="6" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<li><a accesskey="7" href="#Debugging-Facilities">Debugging Facilities</a>
<li><a accesskey="8" href="#GLADE-File-Hierarchy">GLADE File Hierarchy</a>
<li><a accesskey="9" href="#GLADE-Internals">GLADE Internals</a>
<li><a href="#Remote-Shell-Notes">Remote Shell Notes</a>
</ul>

<div class="node">
<p><hr>
<a name="Introduction-to-GLADE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#How-to-Configure-a-Distributed-Application">How to Configure a Distributed Application</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.1 Introduction to GLADE</h3>

<p>An Ada 95 distributed application comprises a number of partitions
which can be executed concurrently on the same machine or, and this is
the interesting part, can be distributed on a network of machines. 
The way in which partitions communicate is described in Annex E of the
Ada 95 reference manual.

   <p>A partition is a set of compilation units that are linked together to
produce an executable binary. A distributed program comprises two or
more communicating partitions.

   <p>The Distributed Systems Annex (DSA) does not describe how a distributed
application should be configured. It is up to the user to define what
are the partitions in his program and on which machines they should be
executed.

   <p>The tool <tt>gnatdist</tt> and its configuration language
allows the user to partition his program and to specify the
machines on which the individual partitions are to execute.

   <p><tt>gnatdist</tt> reads a configuration file (whose syntax is described in
section <a href="#The-Configuration-Language">The Configuration Language</a>) and builds several
executables, one for each partition. It also takes care of launching the
different partitions (default) with parameters that can be specific to
each partition.

<div class="node">
<p><hr>
<a name="How-to-Configure-a-Distributed-Application"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Gnatdist-Command-Line-Options">Gnatdist Command Line Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-GLADE">Introduction to GLADE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.2 How to Configure a Distributed Application</h3>

     <ul>
<li>Write a non-distributed Ada application, to get familiar with the GLADE
environment. Use the categorization pragmas to specify the packages that
can be called remotely.

     <li>When this non-distributed application is working, write a configuration
file that maps the user categorized packages onto specific
partitions. This concerns particularly remote call interface and remote
types packages.  Specify the main procedure of the distributed
application (see <a href="#Partition-Attribute-Main">Partition Attribute Main</a>).

     <li>Type `gnatdist <i>&lt;configuration-file&gt;</i>'.

     <li>Start the distributed application by invoking the start-up shell script
or default Ada program (depending on the Starter option, see <a href="#Pragma-Starter">Pragma Starter</a>).

</ul>

<div class="node">
<p><hr>
<a name="Gnatdist-Command-Line-Options"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Gnatdist-Behind-the-Scenes">Gnatdist Behind the Scenes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-to-Configure-a-Distributed-Application">How to Configure a Distributed Application</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.3 Gnatdist Command Line Options</h3>

<pre class="smallexample">     
     gnatdist [switches] configuration-file [list-of-partitions]
     
</pre>
<!-- We should add some explanations of the gnatdist specific flags -->
<!-- n, -M and on some particular mechanism (a spec without a body). -->
<p>The switches of <tt>gnatdist</tt> are, for the time being, exactly the same
as those of gnatmake, with the addition of <tt>&ndash;PCS</tt>, which allows the
user to override the default selection of distribution runtime library
(PCS). By default <tt>gnatdist</tt> outputs a configuration
report and the actions performed. The switch -n allows <tt>gnatdist</tt> to
skip the first stage of recompilation of the non-distributed
application.

   <p>The names of all configuration files must have the suffix
<tt>.cfg</tt>. There may be several configuration files for the same
distributed application, as the user may want to use different
distributed configurations depending on load and other characteristics
of the computing environment.

   <p>If a list of partitions is provided on the command line of the gnatdist
command, only these partitions will be built. In the following
configuration example, the user can type :

<pre class="smallexample">     
     gnatdist <i>&lt;configuration&gt; &lt;partition_2&gt; &lt;partition_3&gt;</i>
     
</pre>
   <div class="node">
<p><hr>
<a name="Gnatdist-Behind-the-Scenes"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#The-Configuration-Language">The Configuration Language</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Gnatdist-Command-Line-Options">Gnatdist Command Line Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.4 Gnatdist Behind the Scenes</h3>

<p>Here is what goes on behind the scenes in <tt>gnatdist</tt> when building a
distributed application:

     <ul>
<li>Each compilation unit in the program is compiled into an object module
(as for non distributed applications). This is achieved by calling
gnatmake on the sources of the various partitions.

     <li>Stubs and skeletons are compiled into object modules (these are pieces of
code that allow a partition running on machine A to communicate with a
partition running on machine B). Several timestamp checks are performed
to avoid useless code recompilation and stub generation.

     <li><tt>gnatdist</tt> performs a number of consistency checks. For instance it checks
that all packages marked as remote call interface (RCI) and shared
passive (SP) are mapped onto partitions. It also checks that a RCI or SP
package is mapped onto only one partition.

     <li>Finally, the executables for each partition in the program are
created. The code to launch partitions is embedded in the main partition
except if another option has been specified (see <a href="#Pragma-Starter">Pragma Starter</a>). In this case, a shell script (or nothing) is generated to
start the partitions on the appropriate machines. This is specially
useful when one wants to write client / server applications where the
number of instances of the partition is unknown.

   </ul>

<div class="node">
<p><hr>
<a name="The-Configuration-Language"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Command-Line-Options">Partition Command Line Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Gnatdist-Behind-the-Scenes">Gnatdist Behind the Scenes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.5 The Configuration Language</h3>

<p>The configuration language is <i>Ada-like</i>. As the capabilities of GLADE
will evolve, so will this configuration language. Most of the attributes
and pragmas can be overloaded at run-time by command line arguments or
environment variables.

<ul class="menu">
<li><a accesskey="1" href="#Language-Keywords">Language Keywords</a>
<li><a accesskey="2" href="#Pragmas-and-Representation-Clauses">Pragmas and Representation Clauses</a>
<li><a accesskey="3" href="#Configuration-Declaration">Configuration Declaration</a>
<li><a accesskey="4" href="#Partition-Declaration">Partition Declaration</a>
<li><a accesskey="5" href="#Location-Declaration">Location Declaration</a>
<li><a accesskey="6" href="#Partition-Attribute-Main">Partition Attribute Main</a>
<li><a accesskey="7" href="#Pragma-Starter">Pragma Starter</a>
<li><a accesskey="8" href="#Pragma-Boot_005fLocation">Pragma Boot_Location</a>
<li><a accesskey="9" href="#Partition-Attribute-Self_005fLocation">Partition Attribute Self_Location</a>
<li><a href="#Partition-Attribute-Passive">Partition Attribute Passive</a>
<li><a href="#Partition-Attribute-Data_005fLocation">Partition Attribute Data_Location</a>
<li><a href="#Partition-Attribute-Allow_005fLight_005fPCS">Partition Attribute Allow_Light_PCS</a>
<li><a href="#Pragma-Priority">Pragma Priority</a>
<li><a href="#Partition-Attribute-Priority">Partition Attribute Priority</a>
<li><a href="#Partition-Attribute-Host">Partition Attribute Host</a>
<li><a href="#Pragma-Import">Pragma Import</a>
<li><a href="#Partition-Attribute-Directory">Partition Attribute Directory</a>
<li><a href="#Partition-Attribute-Command_005fLine">Partition Attribute Command_Line</a>
<li><a href="#Partition-Attribute-Termination">Partition Attribute Termination</a>
<li><a href="#Partition-Attribute-Reconnection">Partition Attribute Reconnection</a>
<li><a href="#Channel-Declaration">Channel Declaration</a>
<li><a href="#Partition-and-Channel-Attribute-Filter">Partition and Channel Attribute Filter</a>
<li><a href="#Pragma-Registration_005fFilter">Pragma Registration_Filter</a>
<li><a href="#Pragma-Version">Pragma Version</a>
<li><a href="#Partition-Attribute-Task_005fPool">Partition Attribute Task_Pool</a>
<li><a href="#A-Complete-Example">A Complete Example</a>
</ul>

<div class="node">
<p><hr>
<a name="Language-Keywords"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragmas-and-Representation-Clauses">Pragmas and Representation Clauses</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Configuration-Language">The Configuration Language</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.1 Language Keywords</h4>

<p>All the Ada keywords are reserved keywords of the GLADE configuration
language. <tt>gnatdist</tt> generates full Ada code in order to build the
different executables. To avoid naming conflicts between Ada and GLADE
configuration language, all the Ada keywords have been reserved even if
they are not used in the configuration language.

   <p>There are three new keywords:

     <ul>
<li><i>configuration</i> to encapsulate a configuration

     <li><i>Partition</i> that is a predefined type to declare partitions

     <li><i>Channel</i> that is a predefined type to declare channels between
partitions.

   </ul>

<div class="node">
<p><hr>
<a name="Pragmas-and-Representation-Clauses"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Configuration-Declaration">Configuration Declaration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Language-Keywords">Language Keywords</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.2 Pragmas and Representation Clauses</h4>

<p>It is possible to modify the default behavior of the configuration via
a pragma definition.

<pre class="smallexample">     
     PRAGMA ::=
        <b>pragma</b> PRAGMA_NAME [(PRAGMA_ARGUMENTS)];
     
</pre>
   <p>It is also possible to modify the default behavior of all the partitions
(or channels) via an attribute definition clause applied to the
predefined type <b>Partition</b> (or <b>Channel</b>).

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> Partition'ATTRIBUTE_NAME <b>use</b> ATTRIBUTE_ARGUMENTS;
      | <b>for</b> Channel'ATTRIBUTE_NAME <b>use</b> ATTRIBUTE_ARGUMENTS;
     
</pre>
   <p>It is also possible to modify the default behavior of a given partition
(or channel) via an attribute definition clause applied to the partition
(or channel) itself.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'ATTRIBUTE_NAME <b>use</b> ATTRIBUTE_ARGUMENTS;
     
</pre>
   <p>When an attribute definition clause is applied to a given object of a
predefined type, this overrides any attribute definition of the
predefined type. In the next sections, attributes apply to a given
object rather than to the predefined type.

<div class="node">
<p><hr>
<a name="Configuration-Declaration"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Declaration">Partition Declaration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragmas-and-Representation-Clauses">Pragmas and Representation Clauses</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.3 Configuration Declaration</h4>

<p>The distribution of one or several Ada programs is described by a single
configuration unit. This configuration unit has a specification part and
an optional body part. A configuration unit is declared as an Ada
procedure would be. The keyword <b>configuration</b> is reserved for this
purpose.

<pre class="smallexample">     
     CONFIGURATION_UNIT ::=
        <b>configuration</b> IDENTIFIER <b>is</b>
           DECLARATIVE_PART
        [<b>begin</b>
           SEQUENCE_OF_STATEMENTS]
        <b>end</b> [IDENTIFIER];
     
</pre>
   <div class="node">
<p><hr>
<a name="Partition-Declaration"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Location-Declaration">Location Declaration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Configuration-Declaration">Configuration Declaration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.4 Partition Declaration</h4>

<p>In the declarative part, the user declares his partitions and can change
their default behavior. <tt>gnatdist</tt> provides a predefined type
<b>Partition</b>. The user can declare a list of partitions and can also
initialize these partitions with an initial list of Ada units.

<pre class="smallexample">     
     DECLARATIVE_PART ::= {DECLARATIVE_ITEM}
     
     DECLARATIVE_ITEM ::=
        PARTITION_DECLARATION
      | CHANNEL_DECLARATION
      | REPRESENTATION_CLAUSE
      | SUBPROGRAM_DECLARATION
      | PRAGMA
     
     SUBPROGRAM_DECLARATION ::=
        MAIN_PROCEDURE_DECLARATION
      | PROCEDURE_DECLARATION
      | FUNCTION_DECLARATION
     
     PARTITION_DECLARATION ::=
        DEFINING_IDENTIFIER_LIST : Partition
           [:= ENUMERATION_OF_ADA_UNITS];
     
     DEFINING_IDENTIFIER_LIST ::=
        DEFINING_IDENTIFIER {, DEFINING_IDENTIFIER}
     
     STATEMENT ::=
        IDENTIFIER := ENUMERATION_OF_ADA_UNITS;
     
     SEQUENCE_OF_STATEMENTS ::=
        STATEMENT {STATEMENT}
     
</pre>
   <p>Once declared, a partition is an empty list of Ada units. The operator
<b>":="</b> adds the Ada units list on the right side to the current list
of Ada units that are already mapped to the partition. This is a
non-destructive operation. Whether a unit is a relevant Ada unit or not
is checked later on by the back-end of <tt>gnatdist</tt>. These assignments
can occur in the declarative part as well as in the body part.

<pre class="smallexample">     
     ENUMERATION_OF_ADA_UNITS ::= ({ADA_UNIT {, ADA_UNIT}});
     
</pre>
   <div class="node">
<p><hr>
<a name="Location-Declaration"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Main">Partition Attribute Main</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Declaration">Partition Declaration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.5 Location Declaration</h4>

<p>There are several kinds of location in the GLADE configuration
language. We shall present them in the next subsections, but here is a
short overview of these locations:

     <ul>
<li>Boot_Location defines the network locations to use to communicate
with the the boot server during the boot phase

     <li>Self_Location defines the network locations to use by others
to communicate with the current partition

     <li>Data_Location defines the data storage location used by the
current partition to map its shared passive units

   </ul>

   <p>A location is composed of a support name and a specific data for this
support. For instance, a network location is composed of a protocol name
like <i>tcp</i> and a protocol data like <i>&lt;machine&gt;:&lt;port&gt;</i>. A storage
location is composed of a storage support name like <i>dfs</i> (for
Distributed File System) and a storage support data like a directory
<i>/dfs/glade</i>.

<pre class="smallexample">     
     LOCATION      ::= ([Support_Name =&gt;] STRING_LITERAL,
                        [Support_Data =&gt;] STRING_LITERAL)
     
     LOCATION_LIST ::= (LOCATION [,LOCATION)])
     
</pre>
   <p>Note that a location may have an undefined or incomplete support
data. In this case, the support is free to compute a support data. For
instance, ("tcp", "") specifies that the protocol is used but that the
protocol data <i>&lt;machine&gt;:&lt;port&gt;</i> is to be determined by the protocol
itself.

   <p>A location or a list of locations can be can be concatenated into a
single string to be used as a command line option or an environment
variable (see <a href="#Partition-Command-Line-Options">Partition Command Line Options</a>).

   <p>If a partition wants to communicate with another partition once the
location list of the latter is known, the caller will use the first
location of the callee whose protocol is locally available. For
instance, if a callee exports three locations ("N1", "D1"), ("N2", "D2")
and ("N3", "D3"), a caller with protocols N2 and N3 locally available
will try to communicate with the callee using the protocol of name N2
and of specific data D2.

<div class="node">
<p><hr>
<a name="Partition-Attribute-Main"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Starter">Pragma Starter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Location-Declaration">Location Declaration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.6 Partition Attribute Main</h4>

<p>Basically, the distributed system annex (DSA) helps the user in building
a distributed application from a non-distributed application (Of course,
this is not the only possible model offered by DSA). The user can
design, implement and test his application in a non-distributed
environment, and then should be able to switch from the non-distributed
case to a distributed case. As mentioned before, this two-phase design
approach has several advantages.

   <p>In a non-distributed case, the user executes only one main executable
possibly with a name corresponding to the main unit name of his
application. With <tt>gnatdist</tt>, in a distributed case, a main executable
with a name corresponding to the main unit name is responsible for
starting the entire distributed application. Therefore, the user can
start his application the same way he used to do in the non-distributed
case.

   <p>For this reason, the configuration language provides a way to declare
the main procedure of the non-distributed application.

<pre class="smallexample">     
     MAIN_PROCEDURE_DECLARATION ::=
        <b>procedure</b> MAIN_PROCEDURE_IDENTIFIER <b>is in</b> PARTITION_IDENTIFIER;
     
</pre>
   <p>In this case, the partition in which the main procedure has been mapped
is called the main partition. It includes in its code a call to this
main procedure. The main partition has an additional specific role,
because the boot server is located on it (see <a href="#GLADE-Internals">GLADE Internals</a>).

   <p>The main procedures for the other partitions have a null body. However,
the user can also modify this behavior by providing an alternate main
procedure. To do this, an alternate main subprogram has to be declared
and assigned to the partition Main attribute.

<pre class="smallexample">     
     PROCEDURE_DECLARATION ::=
        <b>procedure</b> PROCEDURE_IDENTIFIER;
     
     REPRESENTATION_CLAUSE :=
        <b>for</b> PARTITION_IDENTIFIER'Main <b>use</b> PROCEDURE_IDENTIFIER;
     
</pre>
   <div class="node">
<p><hr>
<a name="Pragma-Starter"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Boot_005fLocation">Pragma Boot_Location</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Main">Partition Attribute Main</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.7 Pragma Starter</h4>

<p>As a default, the main executable is a full Ada starter procedure. That
means that it launches all the other partitions from an Ada program. The
pragma Starter allows the user to ask for one starter or another. When
the partition host is not statically defined (see <a href="#Partition-Attribute-Host">Partition Attribute Host</a>), the starter subprogram will ask for it interactively
when it is executed.

<pre class="smallexample">     
     CONVENTION_LITERAL ::= Ada   |
                            Shell |
                            None
     
     PRAGMA ::=
        <b>pragma</b> Starter ([Convention =&gt;] CONVENTION_LITERAL);
     
</pre>
     <ul>
<li>The default method consists in launching partitions from the main
partition Ada subprogram using a remote shell (see below).

     <li>The user may ask for a Shell script that starts the different partitions
one at a time on the appropriate remote machines, using a remote
shell. As the Ada starter, the Shell script starter ask for partition
hosts interactively when a partition host is not already defined. Having
a textual shell script allows the user to edit it and to modify it
easily.

     <li>The user may ask for a None starter. In this case, it is up to the user
to launch the different partitions. The user may have to provide on the
command line the boot server location (see <a href="#The-GARLIC-PCS">The GARLIC PCS</a>).

   </ul>

<h4 class="subsection">3.5.8 Pragma Remote_Shell</h4>

<p>When pragma Starter is Ada or Shell, the main partition launches the
other partitions. The remote shell used as a default is determined
during GLADE configuration and installation. It is either rsh, remsh or
the argument passed to &ndash;with-rshcmd=[ARG]. The pragma Remote_Shell
allows the user to override the default.

<pre class="smallexample">     
     PRAGMA ::=
        <b>pragma</b> Remote_Shell
          ([Command =&gt;] STRING_LITERAL,
           [Options =&gt;] STRING_LITERAL);
     
</pre>
   <p>The Command parameter indicates the name of the remote shell command
name and the Options parameter corresponds to the additional flags to
pass to the remote shell command.

<div class="node">
<p><hr>
<a name="Pragma-Boot_005fLocation"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Self_005fLocation">Partition Attribute Self_Location</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Starter">Pragma Starter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.9 Pragma Boot_Location</h4>

<p>When a partition starts executing, one of the first steps consists in a
connection to the boot partition where the boot server is located (see
<a href="#The-GARLIC-PCS">The GARLIC PCS</a>). This pragma provides one or several
locations in order to get a connection with the boot partition.

<pre class="smallexample">     
     PRAGMA ::=
        PRAGMA_WITH_NAME_AND_DATA
      | PRAGMA_WITH_LOCATION
      | PRAGMA_WITH_LOCATION_LIST
     
     PRAGMA_WITH_NAME_AND_DATA ::=
        <b>pragma</b> Boot_Location
          ([Protocol_Name =&gt;] STRING_LITERAL,
           [Protocol_Data =&gt;] STRING_LITERAL);
     
     PRAGMA_WITH_LOCATION ::=
        <b>pragma</b> Boot_Location ([Location =&gt;] LOCATION);
     
     PRAGMA_WITH_LOCATION_LIST ::=
        <b>pragma</b> Boot_Location ([Locations =&gt;] LOCATION_LIST);
     
</pre>
   <p>This boot server location can be concatenated into a single string to be
used as a command line option or an environment variable (see
<a href="#Partition-Command-Line-Options">Partition Command Line Options</a>).

   <p><b>Note: pragma Boot_Server is now obsolete. It is recommended to use
pragma Boot_Location. This wording is more consistent with the rest of
the configuration language (see Self_Location <a href="#Partition-Option-self_005flocation">Partition Option self_location</a> and Data_Location <a href="#Partition-Option-data_005flocation">Partition Option data_location</a>).</b>

<div class="node">
<p><hr>
<a name="Partition-Attribute-Self_005fLocation"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Passive">Partition Attribute Passive</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Boot_005fLocation">Pragma Boot_Location</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.10 Partition Attribute Self_Location</h4>

<p>Except for the boot partition on which the boot server is located, a
partition is reachable through a dynamically computed location (for
instance, the partition looks for a free port when the protocol is
tcp). The user may want such a partition to be reachable from a given
location, especially if the user wants to make this partition a boot
mirror. To do so, he can force the partition location with self_location
feature.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Self_Location <b>use</b> LOCATION;
      | <b>for</b> PARTITION_IDENTIFIER'Self_Location <b>use</b> LOCATION_LIST;
     
</pre>
   <p>If the attribute definition clause applies to the predefined type
<b>Partition</b>, the locations have to be incomplete. Otherwise, all the
partitions would be reachable through the same locations, which is
definitively not recommended.

   <p>When an attribute self_location definition clause applies to a given
partition, the protocol units needed for this partition are linked in
the executable. By default, when the self_location attribute is not
redefined, the default protocol used by the partition and loaded in its
executable is the <i>tcp</i> protocol.

<div class="node">
<p><hr>
<a name="Partition-Attribute-Passive"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Data_005fLocation">Partition Attribute Data_Location</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Self_005fLocation">Partition Attribute Self_Location</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.11 Partition Attribute Passive</h4>

<p>By default, a partition is an active partition. This attribute allows to
define a passive partition. In this case, <tt>gnatdist</tt> checks that only
shared passive units are mapped on the partition. As this partition
cannot register itself, its location is hard-coded in all the partitions
that depend on its shared passive units.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Passive <b>use</b> BOOLEAN_LITERAL;
     
</pre>
   <div class="node">
<p><hr>
<a name="Partition-Attribute-Data_005fLocation"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Allow_005fLight_005fPCS">Partition Attribute Allow_Light_PCS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Passive">Partition Attribute Passive</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.12 Partition Attribute Data_Location</h4>

<p>Shared passive units can be mapped on passive or active partitions. In
both cases, it is possible to choose the data storage support and to
configure it with the specific data of a location.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Data_Location <b>use</b> LOCATION;
      | <b>for</b> PARTITION_IDENTIFIER'Data_Location <b>use</b> LOCATION_LIST;
     
</pre>
   <p>When an attribute data_location definition clause applies to a given
partition, the data storage support units needed for this partition are
linked in the executable. By default, when the data_location attribute
is not redefined, the default storage support used by the partition and
loaded in its executable is the <i>dfs</i> support. <i>dfs</i>, Distributed
File System, is a storage support available as soon as files can be
shared between partitions.

   <p>It is not possible to map the different shared passive units of a given
partition on different data storage locations. GLADE requires all the
shared passive units of a given partition to be mapped on the same
storage support. When the attribute data_location applied to a partition
is a list of locations, all the storage support units needed for this
partition are linked in the executable. By default, only the first one
is activated. The user can choose to change the activated support by
another one specified in the location list. This can be done using the
partition option data_location (see <a href="#Partition-Option-data_005flocation">Partition Option data_location</a>).

   <p>As passive partitions cannot be activated, it is not possible to provide
a location list as a data_location attribute. It is not possible to
change dynamically its location either.

<div class="node">
<p><hr>
<a name="Partition-Attribute-Allow_005fLight_005fPCS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Priority">Pragma Priority</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Data_005fLocation">Partition Attribute Data_Location</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.13 Partition Attribute Allow_Light_PCS</h4>

<p>On some circumstances, GLADE can detect that a partition does not need
the full PCS functionalities. This occurs in particular when the
partition does use any task, any RCI unit or any RACW object. Therefore,
the partition does not receive any message that is not a reply to a
previous request. In this case, the PCS does not drag in the tasking
library and a light PCS is linked in the partition executable. 
This specific configuration is automatically determined by GNATDIST with
the ALI file information.

   <p>This optimization can be inappropriate especially when the user wants to
use the "Distributed Shared Memory" storage support which runs Li and
Hudak's algorithm. In this case, messages are exchanged without being
replies to previously sent requests and the normal PCS should be linked
instead of the light one. Note also that GNATDIST cannot know for sure
that the DSM storage support assigned at configuration time is used at
run-time. The user can configure this optimization with the following
attribute.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Allow_Light_PCS <b>use</b> BOOLEAN_LITERAL;
     
</pre>
   <div class="node">
<p><hr>
<a name="Pragma-Priority"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Priority">Partition Attribute Priority</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Allow_005fLight_005fPCS">Partition Attribute Allow_Light_PCS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.14 Pragma Priority</h4>

<p>It might be necessary for real-time applications to get control over the
priority at which a remote procedure call is executed. By default,
the PCS sends the priority of the client to the server which sets the
priority of an anonymous task to this value. The pragma Priority allows
to decide which priority policy should apply in the distributed
application.

<pre class="smallexample">     
     PRIORITY_POLICY_LITERAL ::= Server_Declared
                               | Client_Propagated
     
     PRAGMA ::=
        <b>pragma</b> Priority ([Policy =&gt;] PRIORITY_POLICY_LITERAL);
     
</pre>
     <ul>
<li>The default policy Client_Propagated consists in propagating the client
priority to the server.

     <li>The policy Server_Declared consists in executing the remote procedure
call at a priority specific to the partition. This priority can be
set using the partition attribute Priority.

   </ul>

<div class="node">
<p><hr>
<a name="Partition-Attribute-Priority"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Host">Partition Attribute Host</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Priority">Pragma Priority</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.15 Partition Attribute Priority</h4>

<p>This attribute allows to set the priority at which level a remote
procedure call is executed on a server when the priority policy is
Server_Declared. By default, the default priority of the anonymous task
is the default task priority.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Priority <b>use</b> INTEGER_LITERAL;
     
</pre>
   <div class="node">
<p><hr>
<a name="Partition-Attribute-Host"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Import">Pragma Import</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Priority">Partition Attribute Priority</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.16 Partition Attribute Host</h4>

<p>Logical nodes (or partitions) can be mapped onto physical nodes. The
host-name can be either a static or dynamic value. In case of a static
value, the expression is a string literal. In case of a dynamic value,
the representation clause argument is a function that accepts a string
as parameter and that returns a string value. When the function is
called, the partition name is passed as parameter and the host-name is
returned.

<pre class="smallexample">     
     FUNCTION_DECLARATION ::=
        <b>function</b> FUNCTION_IDENTIFIER
          (PARAMETER_IDENTIFIER : [<b>in</b>] String)
           <b>return</b> String;
     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Host <b>use</b> STRING_LITERAL;
      | <b>for</b> PARTITION_IDENTIFIER'Host <b>use</b> FUNCTION_IDENTIFIER;
     
</pre>
   <p>The signature of the function must be the following : it takes a
string parameter which corresponds to a partition name. It returns
a string parameter which corresponds to the host-name. The function
that returns the host-name can be an Ada function (default) or a shell
script. A pragma Import is used to import a function defined in Ada or
in Shell (see <a href="#Pragma-Import">Pragma Import</a>).

   <p>This function is called on the main partition by the GLADE PCS to launch
a given partition on a given logical node. In case of load balancing,
the function can return the most appropriate among a set of hosts.

<div class="node">
<p><hr>
<a name="Pragma-Import"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Directory">Partition Attribute Directory</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Host">Partition Attribute Host</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.17 Pragma Import</h4>

<p>Two kinds of subprograms are allowed in the GLADE configuration
language. A main procedure is used as a partition Main attribute and a
function is used as a partition Host attribute.

<pre class="smallexample">     
     SUBPROGRAM_DECLARATION ::=
          <b>procedure</b> MAIN_PROCEDURE_IDENTIFIER <b>is</b> <b>in</b> PARTITION_NAME;
        | <b>procedure</b> PROCEDURE_IDENTIFIER;
        | <b>function</b> FUNCTION_IDENTIFIER
             (PARAMETER_IDENTIFIER : [<b>in</b>] String)
              <b>return</b> String;
     
</pre>
   <p>The function can be an Ada function (default) or a shell script. To
import a shell script, the pragma Import must be used:

<pre class="smallexample">     
     PRAGMA ::=
        <b>pragma</b> Import
           ([Entity        =&gt;] FUNCTION_IDENTIFIER,
            [Convention    =&gt;] CONVENTION_LITERAL,
            [External_Name =&gt;] STRING_LITERAL);
     
     <b>pragma</b> Import (Best_Node, Shell, "best-node");
</pre>
   <p>In this case, the GLADE PCS invokes the shell script with the partition
name as a command line argument. The shell script is supposed to return
the partition host-name (see <a href="#Partition-Attribute-Host">Partition Attribute Host</a>).

<div class="node">
<p><hr>
<a name="Partition-Attribute-Directory"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Command_005fLine">Partition Attribute Command_Line</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Import">Pragma Import</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.18 Partition Attribute Directory</h4>

<p>Directory allows the user to specify in which directory the partition
executable is stored. This can be useful in heterogeneous systems when
the user wants to store executables for the same target in a given
directory. Specifying the directory is also useful if the partition
executable is not directly visible from the user environment. For
instance, when a remote command like <b>rsh</b> is invoked, the executable
directory has to be present in the user path. If the Directory
attribute has been specified, the executable full name is used.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Directory <b>use</b> STRING_LITERAL;
     
</pre>
   <div class="node">
<p><hr>
<a name="Partition-Attribute-Command_005fLine"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Termination">Partition Attribute Termination</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Directory">Partition Attribute Directory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.19 Partition Attribute Command_Line</h4>

<p>The user may want to pass arguments on the command line of a
partition. However, when a partition is launched automatically by the
main partition, the partition command line includes only GLADE
arguments. To add arguments on the command line, the user can take
advantage of the following attribute.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Command_Line <b>use</b> STRING_LITERAL;
     
</pre>
   <div class="node">
<p><hr>
<a name="Partition-Attribute-Termination"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Reconnection">Partition Attribute Reconnection</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Command_005fLine">Partition Attribute Command_Line</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.20 Partition Attribute Termination</h4>

<p>The Ada95 Reference Manual does not provide any specific rule to handle
global termination of a distributed application (see <a href="#Abortion-and-Termination">Abortion and Termination</a>).

   <p>In GLADE, by default, a set of partitions terminates when each partition
can terminate and when no message remains to be delivered. A distributed
algorithm that checks for this global condition is activated
periodically by the main boot server.

<pre class="smallexample">     
     TERMINATION_LITERAL ::= Global_Termination |
                              Local_Termination  |
                              Deferred_Termination
     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Termination <b>use</b> TERMINATION_LITERAL;
     
</pre>
     <ul>
<li>When a partition is configured with the global termination policy,
it terminates as soon as the main boot server sends a signal to do
so. The main boot server checks periodically whether the application can
terminate. When all partitions are ready to terminate, the main boot
server sends to each partition a termination request. The global
termination policy is the default policy.

     <li>The deferred termination policy is very similar to the global
termination. The only difference is that when a partition with a
deferred termination policy receives a termination request, it just
ignores it. This policy allows a partition to run forever without
preventing a set of partitions from terminating. This policy is not yet
implemented.

     <li>When a partition is configured with the local termination policy,
it terminates as soon as the classical Ada termination is detected by
the partition. It means that this partition does not wait for the
termination request of the main boot server.

   </ul>

   <p>In any case, when the boot partition dies (and when no alternate boot
partition can elected, see <a href="#The-GARLIC-PCS">The GARLIC PCS</a>), all the
partitions die, whatever their termination policy might be. Note first,
that a partition cannot execute without a boot partition. Second, when
the user wants to kill his non-distributed application, he kills the
main program. Enforcing the mechanism described above ensures that
killing the main partition automatically kills all the partitions, that
is to say the whole distributed application.

<div class="node">
<p><hr>
<a name="Partition-Attribute-Reconnection"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Channel-Declaration">Channel Declaration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Termination">Partition Attribute Termination</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.21 Partition Attribute Reconnection</h4>

<p>When no RCI package is configured on a partition, such a partition can
be launched several times without any problem. When one or more RCI
packages are configured on a partition, such a partition cannot be
launched more than once. If this partition were to be launched
repeatedly, it would not be possible to decide which partition instance
should execute a remote procedure call.

   <p>When a partition crashes or is stopped, one may want to restart this
partition and possibly restore its state - with Shared_Passive packages,
for instance. In such a situation, the partition is already known to
other partitions and possibly marked as a dead partition. Several
policies can be selected:

<pre class="smallexample">     
     RECONNECTION_LITERAL ::= Reject_On_Restart  |
                               Fail_Until_Restart |
                               Block_Until_Restart
     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Reconnection <b>use</b> RECONNECTION_LITERAL;
     
</pre>
     <ul>
<li>When this partition is configured with the Reject_On_Restart
reconnection policy, the dead partition is kept dead and any attempt to
restart it fails. Any remote call to a subprogram located on this
partition results in a Communication_Error exception. The
Reject_On_Restart policy is the default policy.

     <li>When this partition is configured with the Fail_Until_Restart
reconnection policy, the dead partition can be restarted. Any remote
call to a subprogram located on this partition results in an exception
Communication_Error as long as this partition has not been restarted. As
soon as the partition is restarted, remote calls to this partition are
executed normally.

     <li>When this partition is configured with the Block_Until_Restart
reconnection policy, the dead partition partition can be restarted. Any
remote call to a subprogram located on this partition is suspended until
the partition is restarted. As soon as the partition is restarted,
remote calls to this partition are executed normally. The suspended
remote procedure calls to this partition are resumed.

   </ul>

<div class="node">
<p><hr>
<a name="Channel-Declaration"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-and-Channel-Attribute-Filter">Partition and Channel Attribute Filter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Reconnection">Partition Attribute Reconnection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.22 Channel Declaration</h4>

<p>The configuration language not only describes partitions, but also the
connections between them. Such a connection is called a Channel and
represents a bi-directional link between two partitions.

<pre class="smallexample">     
     CHANNEL_DECLARATION ::=
        CHANNEL_IDENTIFIER : Channel
           [:= PARTITION_PEER];
     
     PARTITION_PEER ::= (PARTITION_IDENTIFIER, PARTITION_IDENTIFIER);
     
</pre>
   <p>A partition peer is a pair of distinct partition names. The list order
is not important. Of course, the designated partitions have to be
declared prior to the channel itself.

<pre class="smallexample">     
     A_Channel : Channel := (Partition_1, Partition_2);
     
</pre>
   <p>This gives the link between partitions <i>Partition_1</i> and
<i>Partition_2</i> the name <i>A_Channel</i>. It is not possible to declare
more than one channel between the same two partitions.

<div class="node">
<p><hr>
<a name="Partition-and-Channel-Attribute-Filter"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Registration_005fFilter">Pragma Registration_Filter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Channel-Declaration">Channel Declaration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.23 Partition and Channel Attribute Filter</h4>

<p>GLADE contains a transparent extensible filtering mechanism that allows
the user to define various data transformations to be performed on the
arguments and return values of remote calls. One possible application is
to compress all data before sending it and to decompress it on the
receiving partition.

   <p>With GLADE, it is no longer necessary for the application to take care
of such transformations. Instead, users can write their own data
transformations and hook them into GLADE so that they are automatically
and transparently applied depending on the configuration of the
distributed application.

   <p>By default, no filtering is performed by GLADE, even though the
compression filter is always available. The user can choose to configure
his distributed application to use this filter.

   <p>In order to define filtering, one must first declare the channels
between the partitions of an application. Once a channel is defined, the
data transformation that is to be applied on all data sent through it
can be specified:

<pre class="smallexample">     
     A_Channel : Channel := (Partition_1, Partition_2);
     
     <b>for</b> A_Channel'Filter <b>use</b> "ZIP";
     
</pre>
   <p>This specifies that all data sent over this channel should be
transformed by the filter named <i>ZIP</i>. (There must be a filter with
this name, implemented in the package <i>System.Garlic.Filters.Zip</i>.)

   <p>It may also be useful to specify that a partition use a certain filter
for all remote calls, regardless of the channel (i.e., regardless of the
partition that will receive the remote call). This can be specified
using the attribute 'Filter on a partition:

<pre class="smallexample">     
     <b>for</b> Partition_1'Filter <b>use</b> "ZIP";
     
</pre>
   <p>or

<pre class="smallexample">     
     <b>for</b> Partition'Filter <b>use</b> "ZIP";
     
</pre>
   <p>The latter sets the default filter for all partitions of the
application, the former only sets the default filter for the partition
<i>Partition_1</i>.  It is also possible to apply a default filter and to
override this default for specific channels:

<pre class="smallexample">     
     My_Channel : Channel := (Partition_1, Partition_2);
     
     <b>for</b> My_Channel'Filter  <b>use</b> "ZIP";
     <b>for</b> Partition_1'Filter <b>use</b> "Some_Other_Filter";
     
</pre>
   <p>This makes <i>Partition_1</i> use <i>Some_Other_Filter</i> for all remote
calls except for any communication with <i>Partition_2</i>, where the
filter <i>ZIP</i> is applied.

   <p><tt>gnatdist</tt> takes care of consistency checking of a filter
definition. For instance, multiple filter definitions for the same
channel are not allowed. Filtering is only active if specified
explicitly in the configuration file.

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> CHANNEL_IDENTIFIER'Filter <b>use</b> STRING_LITERAL;
      | <b>for</b> PARTITION_IDENTIFIER'Filter <b>use</b> STRING_LITERAL;
     
</pre>
   <div class="node">
<p><hr>
<a name="Pragma-Registration_005fFilter"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Pragma-Version">Pragma Version</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-and-Channel-Attribute-Filter">Partition and Channel Attribute Filter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.24 Pragma Registration_Filter</h4>

<p>Some filtering algorithms require that some parameters be sent to the
receiver first to enable it to correctly de-filter the data. If this is
the case, it may be necessary to filter these parameters as well. For
such purposes, it is possible to install a global filter for all
partitions, which will then be used to filter the parameters of other
filters. This filter is called the registration filter. It can be set by
a pragma because a pragma applies to the configuration:

<pre class="smallexample">     
     PRAGMA ::=
        <b>pragma</b> Registration_Filter ([Filter =&gt;] STRING_LITERAL);
     
</pre>
   <div class="node">
<p><hr>
<a name="Pragma-Version"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Attribute-Task_005fPool">Partition Attribute Task_Pool</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Registration_005fFilter">Pragma Registration_Filter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.25 Pragma Version</h4>

<p>A library unit is consistent if the same version of its declaration is
used throughout (see <a href="#Consistency-and-Elaboration">Consistency and Elaboration</a>). It can be
useful to deactivate these checks, especially when the user wants to be
able to update a server without updating a client.

<pre class="smallexample">     
     PRAGMA ::=
        <b>pragma</b> Version ([Check =&gt;] BOOLEAN_LITERAL);
     
</pre>
   <div class="node">
<p><hr>
<a name="Partition-Attribute-Task_005fPool"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#A-Complete-Example">A Complete Example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pragma-Version">Pragma Version</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.26 Partition Attribute Task_Pool</h4>

<p>When multiple remote subprogram calls occur on the same partition, they
are handled by several anonymous tasks. These tasks can be allocated
dynamically or re-used from a pool of (preallocated) tasks. When a
remote subprogram call is completed, the anonymous task can be
deallocated or queued in a pool in order to be re-used for further
remote subprogram calls. The number of tasks in the anonymous tasks pool
can be configured by means of three independent parameters.

     <ul>
<li>The task pool minimum size indicates the number of anonymous tasks
preallocated and always available in the GLADE PCS. Preallocating
anonymous tasks can be useful in real-time systems to prevent task
dynamic allocation.

     <li>The task pool high size is a ceiling. When a remote subprogram
call is completed, its anonymous task is deallocated if the number of
tasks already in the pool is greater than the ceiling. If not, then the
task is queued in the pool.

     <li>The task pool maximum size indicates the maximum number of anonymous
tasks in the GLADE PCS. In other words, it provides a way to limit the
number of remote calls in the PCS. When a RPC request is received, if
the number of active remote calls is greater than the task pool maximum
size, then the request is kept pending until an anonymous task completes
its own remote call and becomes available.

   </ul>

<pre class="smallexample">     
     REPRESENTATION_CLAUSE ::=
        <b>for</b> PARTITION_IDENTIFIER'Task_Pool <b>use</b> TASK_POOL_SIZE_ARRAY;
     
     TASK_POOL_SIZE_ARRAY ::=
       (NATURAL_LITERAL,  <i>--  Task Pool Minimum Size</i>
        NATURAL_LITERAL,  <i>--  Task Pool High Size</i>
        NATURAL_LITERAL); <i>--  Task Pool Maximum Size</i>
     
</pre>
   <p>In order to have only one active remote call at a  time, the task pool
configuration is declared as follows:

<pre class="smallexample">     
     <b>for</b> Partition'Task_Pool <b>use</b> (0, 0, 1);
     
</pre>
   <div class="node">
<p><hr>
<a name="A-Complete-Example"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Attribute-Task_005fPool">Partition Attribute Task_Pool</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Configuration-Language">The Configuration Language</a>
<br>
</div>

<h4 class="subsection">3.5.27 A Complete Example</h4>

<p>Almost every keyword and construct defined in the configuration language
has been used in the following sample configuration file.

<pre class="smallexample">     
     <b>01</b> <b>configuration</b> MyConfig <b>is</b>
     <b>02</b>
     <b>03</b>   Partition_1 : Partition := ();
     <b>04</b>   <b>procedure</b> Master_Procedure <b>is</b> <b>in</b> Partition_1;
     <b>05</b>
     <b>06</b>   Partition_2, Partition_3 : Partition;
     <b>07</b>
     <b>08</b>   <b>for</b> Partition_2'Host <b>use</b> "foo.bar.com";
     <b>09</b>
     <b>10</b>   <b>function</b> Best_Node (Partition_Name : String) <b>return</b> String;
     <b>11</b>   <b>pragma</b> Import (Shell, Best_Node, "best-node");
     <b>12</b>   <b>for</b> Partition_3'Host <b>use</b> Best_Node;
     <b>13</b>
     <b>14</b>   Partition_4 : Partition := (RCI_B5);
     <b>15</b>
     <b>16</b>   <b>for</b> Partition_1'Directory <b>use</b> "/usr/you/test/bin";
     <b>17</b>   <b>for</b> Partition'Directory <b>use</b> "bin";
     <b>18</b>
     <b>19</b>   <b>procedure</b> Another_Main;
     <b>20</b>   <b>for</b> Partition_3'Main <b>use</b> Another_Main;
     <b>21</b>
     <b>22</b>   <b>for</b> Partition_3'Reconnection <b>use</b> Block_Until_Restart;
     <b>23</b>   <b>for</b> Partition_4'Command_Line <b>use</b> "-v";
     <b>24</b>   <b>for</b> Partition_4'Termination <b>use</b> Local_Termination;
     <b>25</b>
     <b>26</b>   <b>pragma</b> Starter (Method =&gt; Ada);
     <b>27</b>
     <b>28</b>   <b>pragma</b> Boot_Server
     <b>29</b>     (Protocol_Name =&gt; "tcp",
     <b>30</b>      Protocol_Data =&gt; "`hostname`:`unused-port`");
     <b>31</b>
     <b>32</b>   <b>pragma</b> Version (False);
     <b>33</b>
     <b>34</b>   Channel_1 : Channel := (Partition_1, Partition_4);
     <b>35</b>   Channel_2 : Channel := (Partition_2, Partition_3);
     <b>36</b>
     <b>37</b>   <b>for</b> Channel_1'Filter <b>use</b> "ZIP";
     <b>38</b>   <b>for</b> Channel_2'Filter <b>use</b> "My_Own_Filter";
     <b>39</b>   <b>for</b> Partition'Filter <b>use</b> "ZIP";
     <b>40</b>
     <b>41</b>   <b>pragma</b> Registration_Filter ("Some_Filter");
     <b>42</b>
     <b>43</b> <b>begin</b>
     <b>44</b>    Partition_2 := (RCI_B2, RCI_B4, Normal);
     <b>45</b>    Partition_3 := (RCI_B3);
     <b>46</b> <b>end</b> MyConfig;
     
</pre>
     <ol type=1 start=1>

     <li><b>Line 01</b>
Typically, after having created the following configuration file the user
types:

     <pre class="smallexample">          
          gnatdist myconfig.cfg
          
     </pre>
     <p>If the user wants to build only some partitions then he will list the
partitions to build on the <tt>gnatdist</tt> command line as follows:

     <pre class="smallexample">          
          gnatdist myconfig.cfg partition_2 partition_3
          
     </pre>
     <p>The name of the file prefix must be the same as the name of the
configuration unit, in this example <tt>myconfig.cfg</tt>. The file suffix
must be <tt>cfg</tt>. For a given distributed application the user can have
as many different configuration files as desired.

     <li><b>Line 04</b>
Partition 1 contains no RCI package. However, it will contain the main
procedure of the distributed application, called <i>Master_Procedure</i> in
this example. If the line <i>procedure Master_Procedure is in
Partition_1;</i> was missing, Partition 1 would be completely empty. This is
forbidden, because a partition has to contain at least one library unit.

     <p><tt>gnatdist</tt> produces an executable with the name of <i>Master_Procedure</i>
which will start the various partitions on their host machines in the
background. The main partition is launched in foreground. Note that by
killing this main procedure the whole distributed application is terminated.

     <li><b>Line 08</b>
Specify the host on which to run partition 2.

     <li><b>Line 12</b>
Use the value returned by a program to figure out at execution time the
name of the host on which partition 3 should execute.  For instance,
execute the shell script <tt>best-node</tt> which takes the partition name as
parameter and returns a string giving the name of the machine on which
partition_3 should be launched.

     <li><b>Line 14</b>
Partition 4 contains one RCI package RCI_B5 No host is specified for
this partition. The startup script will ask for it interactively when it
is executed.

     <li><b>Line 16</b>
Specify the directory in which the executable of partition partition_1
will be stored.

     <li><b>Line 17</b>
Specify the directory in which all the partition executables will be
stored (except partition_1, see <a href="#Pragmas-and-Representation-Clauses">Pragmas and Representation Clauses</a>). Default is the current directory.

     <li><b>Line 20</b>
Specify the partition main subprogram to use in a given partition.

     <li><b>Line 22</b>
Specify a reconnection policy in case of a crash of Partition_3. Any attempt to
reconnect to Partition_3 when this partition is dead will be
blocked until Partition_3 restarts. By default, any restart is
rejected (Reject_On_Restart). Another policy is to raise
Communication_Error on any reconnection attempt until Partition_3 has
been restarted.

     <li><b>Line 23</b>
Specify additional arguments to pass on the command line when a given
partition is launched.

     <li><b>Line 24</b>
Specify a termination mechanism for partition_4. The default is to
compute a global distributed termination. When Local_Termination is
specified a partition terminates as soon as local termination is
detected (standard Ada termination).

     <li><b>Line 26</b>
Specify the kind of startup method the user wants. There are 3
possibilities: Shell, Ada and None. Specifying <i>Shell</i> builds a shell
script. All the partitions will be launched from a shell script.  If
<i>Ada</i> is chosen, then the main Ada procedure itself is used to launch
the various partitions. If method <i>None</i> is chosen, then no launch
method is used and the user must start each partition manually.

     <p>If no starter is given, then an Ada starter will be used.

     <p>In this example, Partition_2, Partitions_3 and Partition_4 will be
started from Partition_1 (ie from the Ada procedure Master_Procedure).

     <li><b>Line 30</b>
Specify the use of a particular boot server. It is especially useful
when the default port used by the GLADE PCS (randomly computed during
GLADE installation) is already assigned.

     <li><b>Line 32</b>
It is a bounded error to elaborate a partition of a distributed
program that contains a compilation unit that depends on a different
version of the declaration of an RCI library unit than the one included in
the partition to which the RCI library unit was assigned. When the
pragma Version is set to False, no consistency check is performed.

     <li><b>Line 335</b>
Declare two channels. Other channels between partitions remain
unknown.

     <li><b>Line 37</b>
Use transparent compression / decompression for the arguments and
results of any remote calls on channel <i>Channel_1</i>, i.e. between
<i>Partition_1</i> and <i>Partition_4</i>.

     <li><b>Line 38</b>
Use filter <i>My_Own_Filter</i> on any declared channel ie <i>Channel_1</i>
amd <i>Channel_2</i>. As <i>Channel_1</i> filter attribute is already
assigned, this applies only to <i>Channel_2</i>. This filter must be
implemented in a package <i>System.Garlic.Filters.My_Own_Filter</i>.

     <li><b>Line 39</b>
For all data exchanged between partitions, use the filter <i>ZIP</i>. (I.e. 
for both arriving remote calls as well as for calls made by a
partition.)

     <li><b>Line 41</b>
<i>Some_Filter</i> will be used to exchange a filter's parameters between
two partitions. <i>Some_Filter</i> itself must be an algorithm that doesn't
need its own parameters to be filtered again. This filter must be
implemented in a package <i>System.Garlic.Filters.Some_Filter</i>.

     <li><b>Line 43</b>
The configuration body is optional. The user may have fully described
his configuration in the declaration part.

     <li><b>Line 44</b>
Partition 2 contains two RCI packages RCI_B2 and RCI_B4 and a normal
package. A normal package is not categorized.

     <li><b>Line 45</b>
Partition 3 contains one RCI package RCI_B3

        </ol>

<div class="node">
<p><hr>
<a name="Partition-Command-Line-Options"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Debugging-Facilities">Debugging Facilities</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Configuration-Language">The Configuration Language</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.6 Partition Command Line Options</h3>

<p>Most of the previous attributes and pragmas can be modified at
run-time. The user can redefine some of the configuration options by
defining shell environment variables or by passing arguments on the
command line of a partition executable. In general, for a given feature
(Aa_Bb_Cc), there is a corresponding environment variable (AA_BB_CC)
and a corresponding command line option (<code>--</code>aa_bb_cc).

   <p>The environment variable (AA_BB_CC) can be set to a value of the
expected type. When a partition is executed from such a shell, the value
assigned in the configuration file is replaced by the value of the
environment variable. If the user shell is <tt>sh</tt>, <tt>bash</tt> or <tt>zsh</tt>,
type:

<pre class="smallexample">     
     AA_BB_CC=&lt;x&gt;
     export AA_BB_CC
     
</pre>
   <p>If the user shell is <tt>csh</tt> or <tt>tcsh</tt>, type:

<pre class="smallexample">     
     setenv AA_BB_CC &lt;x&gt;
     
</pre>
   <p>where &lt;x&gt; is a value of the expected type.

   <p>When the partition is launched with a command line option
<code>--</code>aa_bb_cc &lt;x&gt;, the value assigned in the configuration file or
by the shell environment variable is replaced by &lt;x&gt;.

   <p>For some environment variables, the value of the environment variable
may be irrelevant. For some command line options, no extra argument is
needed.  In the following, type None means that extra information is not
needed. The feature is activated as soon as the environment variable
exists or as soon as the option is passed on the command line.

   <p>The precedence order for specifying a run-time parameter is as follows:
first the the command line option, then the environment variable and
finally the configuration attribute or pragma.

   <p>A location can be concatenated into a single string to be used as a
command line option or an environment variable. The formatted string
must conform to the notation &lt;support_name&gt;://&lt;support_data&gt;. Most
commonly, a network location string is tcp://&lt;machine&gt;:&lt;port&gt;, that
means that the protocol name is <i>tcp</i>, the protocol data which is
specific to the protocol name is <i>&lt;machine&gt;:&lt;port&gt;</i>.

   <p>A list of locations can be concatenated into a single string as
well. Location strings are separated by spaces. To be used as a command
line option, it is possible to quote this string. Most commonly, a
network locations string is "tcp://&lt;machine&gt;:&lt;port1&gt;
tcp://&lt;machine&gt;:&lt;port2&gt;".

<ul class="menu">
<li><a accesskey="1" href="#Partition-Option-boot_005flocation">Partition Option boot_location</a>
<li><a accesskey="2" href="#Partition-Option-self_005flocation">Partition Option self_location</a>
<li><a accesskey="3" href="#Partition-Option-data_005flocation">Partition Option data_location</a>
<li><a accesskey="4" href="#Partition-Option-nolaunch">Partition Option nolaunch</a>
<li><a accesskey="5" href="#Partition-Option-detach">Partition Option detach</a>
<li><a accesskey="6" href="#Partition-Option-slave">Partition Option slave</a>
<li><a accesskey="7" href="#Partition-Option-boot_005fmirror">Partition Option boot_mirror</a>
<li><a accesskey="8" href="#Partition-Option-mirror_005fexpected">Partition Option mirror_expected</a>
<li><a accesskey="9" href="#Partition-Option-connection_005fhits">Partition Option connection_hits</a>
<li><a href="#Partition-Option-reconnection">Partition Option reconnection</a>
<li><a href="#Partition-Option-termination">Partition Option termination</a>
<li><a href="#Partition-Option-trace">Partition Option trace</a>
<li><a href="#Partition-Option-replay">Partition Option replay</a>
</ul>

<div class="node">
<p><hr>
<a name="Partition-Option-boot_005flocation"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-self_005flocation">Partition Option self_location</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Command-Line-Options">Partition Command Line Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.1 Partition Option boot_location</h4>

<p>This option sets the boot server location (see <a href="#Pragma-Boot_005fLocation">Pragma Boot_Location</a>
for details).

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%"><br></td></tr><tr align="left"><td valign="top" width="33%">BOOT_LOCATION </td><td valign="top" width="33%"><code>--</code>boot_location  </td><td valign="top" width="33%">Formatted String
   <br></td></tr></table>

   <p>The formatted string must conform to the location notation (see
<a href="#Location-Declaration">Location Declaration</a> and <a href="#Partition-Command-Line-Options">Partition Command Line Options</a>. Most commonly, this would be tcp://&lt;machine&gt;:&lt;port&gt;.

<div class="node">
<p><hr>
<a name="Partition-Option-self_005flocation"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-data_005flocation">Partition Option data_location</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-boot_005flocation">Partition Option boot_location</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.2 Partition Option self_location</h4>

<p>This option sets the current partition location (see <a href="#Partition-Attribute-Self_005fLocation">Partition Attribute Self_Location</a> for details).

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%"><br></td></tr><tr align="left"><td valign="top" width="33%">SELF_LOCATION </td><td valign="top" width="33%"><code>--</code>self_location  </td><td valign="top" width="33%">Formatted String
   <br></td></tr></table>

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">SELF_LOCATION </td><td valign="top" width="33%"><code>--</code>self_location </td><td valign="top" width="33%">Formatted String
   <br></td></tr></table>

   <p>The formatted string must conform to the location notation (see
<a href="#Location-Declaration">Location Declaration</a> and <a href="#Partition-Command-Line-Options">Partition Command Line Options</a>. Most commonly, this would be tcp://&lt;machine&gt;:&lt;port&gt;.

<div class="node">
<p><hr>
<a name="Partition-Option-data_005flocation"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-nolaunch">Partition Option nolaunch</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-self_005flocation">Partition Option self_location</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.3 Partition Option data_location</h4>

<p>This option sets the location of the data storage on which the shared
passive units of the current partition are mapped (see <a href="#Partition-Attribute-Data_005fLocation">Partition Attribute Data_Location</a> for details). This location has to be
compatible with one of locations provided in the configuration file,
that means the partition option data_location must have a support name
of one of the storage locations specified in the configuration file.

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%"><br></td></tr><tr align="left"><td valign="top" width="33%">DATA_LOCATION </td><td valign="top" width="33%"><code>--</code>data_location  </td><td valign="top" width="33%">Formatted String
   <br></td></tr></table>

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">DATA_LOCATION </td><td valign="top" width="33%"><code>--</code>DATA_location </td><td valign="top" width="33%">Formatted String
   <br></td></tr></table>

   <p>The formatted string must conform to the location notation (see
<a href="#Location-Declaration">Location Declaration</a> and <a href="#Partition-Command-Line-Options">Partition Command Line Options</a>. Most commonly, this would be dfs://&lt;directory&gt;.

<div class="node">
<p><hr>
<a name="Partition-Option-nolaunch"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-detach">Partition Option detach</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-data_005flocation">Partition Option data_location</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.4 Partition Option nolaunch</h4>

<p>This feature is useful when the configuration has been built with an Ada
starter. When this feature is activated, the main partition does not
launch the other partitions anymore. The user has to launch them by hand.

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">NOLAUNCH </td><td valign="top" width="33%"><code>--</code>nolaunch </td><td valign="top" width="33%">None
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-detach"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-slave">Partition Option slave</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-nolaunch">Partition Option nolaunch</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.5 Partition Option detach</h4>

<p>This option is not intended to be specified by the user. When this
feature is activated, the process forks itself and the child closes its
standard input, output and error descriptors. This feature is always
activated when a partition is launched from the main partition using a
remote shell (with a starter Ada or Shell).

   <p>The only case where it can be useful is for a configuration built with a
Shell starter. In this case, the user can edit the shell script to pipe
the output of a partition into a file. To do so, the detach feature has
to be removed.

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">DETACH </td><td valign="top" width="33%"><code>--</code>detach </td><td valign="top" width="33%">None
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-slave"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-boot_005fmirror">Partition Option boot_mirror</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-detach">Partition Option detach</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.6 Partition Option slave</h4>

<p>This feature is not supposed to be used by the user. When
this feature is activated, this partition cannot be a boot server
partition anymore. This is useful when a partition has been configured
as a boot partition and when the user does not want it to be a main
partition anymore.

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">SLAVE </td><td valign="top" width="33%"><code>--</code>slave </td><td valign="top" width="33%">None
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-boot_005fmirror"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-mirror_005fexpected">Partition Option mirror_expected</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-slave">Partition Option slave</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.7 Partition Option boot_mirror</h4>

<p>By default, a partition is not a boot mirror, except for a boot partition
on which the boot server is located. The user can force a
partition to be a boot mirror.

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">BOOT_MIRROR </td><td valign="top" width="33%"><code>--</code>boot_mirror </td><td valign="top" width="33%">None
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-mirror_005fexpected"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-connection_005fhits">Partition Option connection_hits</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-boot_005fmirror">Partition Option boot_mirror</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.8 Partition Option mirror_expected</h4>

<p>This option suspends the execution of the distributed application
until there is at least one boot mirror partition available, excluding
the boot server.

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">MIRROR_EXPECTED </td><td valign="top" width="33%"><code>--</code>mirror_expected </td><td valign="top" width="33%">None
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-connection_005fhits"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-reconnection">Partition Option reconnection</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-mirror_005fexpected">Partition Option mirror_expected</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.9 Partition Option connection_hits</h4>

<p>This option sets the number of times a partition tries to connect to
the boot server before raising a Communication_Error exception.

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">CONNECTION_HITS </td><td valign="top" width="33%"><code>--</code>connection_hits </td><td valign="top" width="33%">Natural
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-reconnection"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-termination">Partition Option termination</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-connection_005fhits">Partition Option connection_hits</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.10 Partition Option reconnection</h4>

<p>This option sets the reconnection policy (see <a href="#Partition-Attribute-Reconnection">Partition Attribute Reconnection</a> for details).

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">RECONNECTION </td><td valign="top" width="33%"><code>--</code>reconnection </td><td valign="top" width="33%">Reconnection_Type
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-termination"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-trace">Partition Option trace</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-reconnection">Partition Option reconnection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.11 Partition Option termination</h4>

<p>This option sets the termination policy (see <a href="#Partition-Attribute-Termination">Partition Attribute Termination</a> for details).

   <p><table summary=""><tr align="left"><td valign="top" width="33%">Environment Variable </td><td valign="top" width="33%">Command Line Option </td><td valign="top" width="33%">Type
<br></td></tr><tr align="left"><td valign="top" width="33%">TERMINATION </td><td valign="top" width="33%"><code>--</code>termination </td><td valign="top" width="33%">Termination_Type
   <br></td></tr></table>

<div class="node">
<p><hr>
<a name="Partition-Option-trace"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Partition-Option-replay">Partition Option replay</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-termination">Partition Option termination</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.12 Partition Option trace</h4>

<p>GLADE has a facility for trace/replay-based debugging. If trace mode
is turned on, GLADE will record into a trace file all messages received by
a partition. The trace file can then be used to replay the
execution of the partition, in isolation.

   <p>To get a partition to generate a trace file, it has to be given the
command line argument <code>--</code>trace. This is most easily done by using
a command line option (see <a href="#Partition-Attribute-Command_005fLine">Partition Attribute Command_Line</a>) in
the configuration file to add <code>--</code>trace to the command lines of the
partitions whose executions are to be replayed. When the application has
been built, and started using the starter, as usual,
the trace files will be generated. It is also possible to build the
distributed application with the None starter and then to include the
<code>--</code>trace argument on the command line.

   <p>As a default, the file name of the trace file is the name of the
partition's executable (i.e. the string returned by the standard
procedure Ada.Command_Line.Command_Name) with a suffix <tt>.ptf</tt>. <tt>ptf</tt>
stands for Partition Trace File. It contains all the incoming requests
delivered to the current partition. The file name can be changed with
the <code>--</code>trace_file &lt;othername&gt; command line argument.

   <p>Note that when a remote partition is launched with <tt>rsh</tt> under Unix,
GLADE invokes the executable's name of this partition with its absolute
path included. Therefore, when <code>--</code>trace is passed on the command
line, the partition trace file includes the absolute path as well. If a
file name with a relative path is passed on the command line following
the <code>--</code>trace_file argument, then the home user's directory is
concatenated to the <code>--</code>trace_file argument.

<div class="node">
<p><hr>
<a name="Partition-Option-replay"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Option-trace">Partition Option trace</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Partition-Command-Line-Options">Partition Command Line Options</a>
<br>
</div>

<h4 class="subsection">3.6.13 Partition Option replay</h4>

<p>In order to replay a partition whose execution has been previously
traced, the command line argument <code>--</code>replay is required. In addition,
the special boot server location "replay://" has to be specified,
i.e. by using the <code>--</code>boot_location replay:// command line argument.

   <p>To replay a traced execution of partition whose executable is named
<tt>part</tt>, we start it with the command

<pre class="smallexample">     
     % part [<code>--</code>nolaunch] [<code>--</code>slave] <code>--</code>replay <code>--</code>boot_location replay://
     
</pre>
   <p>possibly under the control of a debugger, such as gdb.

   <p>Since the exact contents of the messages received is recorded,
differences in input from external sources (such as standard input)
during replay will most likely give unexpected results. Also, replay of
applications whose behavior is inherently non-deterministic - for example if
they  use tasking - will be problematic.

   <p>N.B. It is important that the same executable is used for replay as
when the trace file was generated, otherwise strange behavior can be
expected.

<div class="node">
<p><hr>
<a name="Debugging-Facilities"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#GLADE-File-Hierarchy">GLADE File Hierarchy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Partition-Command-Line-Options">Partition Command Line Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.7 Debugging Facilities</h3>

<p>To trace his application, the user sets the following two environment variables
to true. The variable S_RPC provides information on what is going on the
execution of remote procedure calls (resolved in System.RPC -
s-rpc.adb). The variable S_PARINT provides information on partitions and
units status (resolved in System.Partition_Interface -
s-parint.adb). For instance, using sh, bash or zsh, type:

<pre class="smallexample">     
     S_RPC=true;    export S_RPC
     S_PARINT=true; export S_PARINT
     
</pre>
   <div class="node">
<p><hr>
<a name="GLADE-File-Hierarchy"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#GLADE-Internals">GLADE Internals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Debugging-Facilities">Debugging Facilities</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.8 GLADE File Hierarchy</h3>

<p>All GLADE intermediate files (object files, etc) are stored under a
common directory named "dsa". The user may remove this whole directory and
its content when he does not intend to rebuild his distributed
applications.

<div class="node">
<p><hr>
<a name="GLADE-Internals"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Remote-Shell-Notes">Remote Shell Notes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#GLADE-File-Hierarchy">GLADE File Hierarchy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.9 GLADE Internals</h3>

<p>The default GLADE PCS is called GARLIC, which stands for Generic Ada Reusable
Library for Interpartition Communication. Most of the previous features
like filtering, trace / replay, termination, reconnection, version
consistency and remote launching are provided via <tt>gnatdist</tt> specific
features. Some of these features are not configurable by the user.

<ul class="menu">
<li><a accesskey="1" href="#The-GARLIC-PCS">The GARLIC PCS</a>
<li><a accesskey="2" href="#The-PolyORB-PCS">The PolyORB PCS</a>
<li><a accesskey="3" href="#Heterogeneous-System">Heterogeneous System</a>
<li><a accesskey="4" href="#Allocating-Partition-Ids">Allocating Partition Ids</a>
<li><a accesskey="5" href="#Executing-Concurrent-Remote-Calls">Executing Concurrent Remote Calls</a>
<li><a accesskey="6" href="#Priority-Inheritance">Priority Inheritance</a>
<li><a accesskey="7" href="#Remote-Call-Abortion">Remote Call Abortion</a>
<li><a accesskey="8" href="#User-Filter-Implementation">User Filter Implementation</a>
</ul>

<div class="node">
<p><hr>
<a name="The-GARLIC-PCS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#The-PolyORB-PCS">The PolyORB PCS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#GLADE-Internals">GLADE Internals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.1 The GARLIC PCS</h4>

<p>When a partition starts executing, one of the first elaboration steps
is a registration with the partition id server and with the RCI
name server. These two servers are located on a boot server.

   <p>The partition id server is used to allocate a unique partition id when
a new partition registers. The id server also replies to information queries
from other partitions. This information includes the ip
address, the port on which the partition is waiting for requests and all
its configuration parameters (termination policy, reconnection policy,
filters, ...).

   <p>The RCI name server is used to register newly elaborated RCI
packages. This RCI package registration occurs once the partition has
been allocated a partition id. The partition registers its RCI and SP
packages with their names, their version ids and internal information.

   <p>As described previously, the boot server partition can be replicated on
boot mirrors, in order to prevent this partition from being a single
point of failure. A partition has always to connect to a boot server or
a boot mirror in order to get a minimal information set on the other
existing partitions.

   <p>The boot server is the first boot mirror of the system. A new partition
declared as a boot mirror joins the group of boot mirrors. The group of
boot mirrors operates as a token ring: any request from a new partition to
a boot mirror is sent on the ring through a token. A request can traverse the
ring once or twice before being approved by all the other boot
mirrors.

   <p>When the boot server dies, a new boot server is elected among the
remaining boot mirrors. A boot server is responsible for the global
termination detection. That is why a new boot server has to be elected.

<div class="node">
<p><hr>
<a name="The-PolyORB-PCS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Heterogeneous-System">Heterogeneous System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-GARLIC-PCS">The GARLIC PCS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.2 The PolyORB PCS</h4>

<p>As an alternative to GARLIC, PolyORB can be used as the PCS for GLADE. 
This is achieved using the <tt>&ndash;PCS=polyorb</tt> command line switch for
<tt>gnatdist</tt>. PolyORB can also be configured as the default PCS at
GLADE build time. Using <tt>&ndash;PCS=polyorb</tt> requires a working PolyORB
setup. Please refer to the PolyORB User's Guide for complete installation
instructions.

<div class="node">
<p><hr>
<a name="Heterogeneous-System"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Allocating-Partition-Ids">Allocating Partition Ids</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-PolyORB-PCS">The PolyORB PCS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.3 Heterogeneous System</h4>

<p>The GNAT environment provides default stream attributes, except for non-remote
access types (see <a href="#Transmitting-Dynamic-Structure">Transmitting Dynamic Structure</a> and
<a href="#Marshaling-and-Unmarshaling-Operations">Marshaling and Unmarshaling Operations</a>). The implementation of
the default attributes of predefined types can be found in
<i>System.Stream_Attributes</i> (s-stratt.adb).

   <p>The GLADE implementation overloads the GNAT default marshaling and
unmarshaling subprograms with its own subprograms, which format data
according to a <i>XDR</i>-like protocol. Therefore, any GLADE application
will work in an heterogeneous environment.

   <p>If the user wants to keep using the GNAT default attributes for
performance purposes, or to use another protocol to marshal and
unmarshal predefined types, he can replace <tt>s-stratt.adb</tt> by a more
appropriate implementation.

<div class="node">
<p><hr>
<a name="Allocating-Partition-Ids"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Executing-Concurrent-Remote-Calls">Executing Concurrent Remote Calls</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Heterogeneous-System">Heterogeneous System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.4 Allocating Partition Ids</h4>

<p>The Partition_ID is allocated dynamically, at run-time. Each partition
connects to a Partition ID Server which is located on the boot server
and asks for a free Partition_ID. The advantage of this approach is that
it supports easily client / server solution (client partitions may be
duplicated, they will obtain different Partition Ids). There is no need
to recompile or relink all the partitions when a new partition is added
to the system. The Partition_ID is not tight in any way to a specific
protocol or to a specific location.

<div class="node">
<p><hr>
<a name="Executing-Concurrent-Remote-Calls"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Priority-Inheritance">Priority Inheritance</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Allocating-Partition-Ids">Allocating Partition Ids</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.5 Executing Concurrent Remote Calls</h4>

<p>When multiple remote subprogram calls occur on the same partition, they
are handled by several anonymous tasks. The number of tasks in the
anonymous tasks pool can be configured by three figures (see
<a href="#Partition-Attribute-Task_005fPool">Partition Attribute Task_Pool</a>). Therefore, the user may have to
synchronize global data in the Remote_Call_Interface or Remote_Types
unit to preserve concurrent access on data. If the user want to suppress
the multiple requests features, he can force the configuration of the
anonymous tasks pool to (0 | 1, 0 | 1, 1). That means that there will be
at most one anonymous task running at a time.

<div class="node">
<p><hr>
<a name="Priority-Inheritance"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Remote-Call-Abortion">Remote Call Abortion</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Executing-Concurrent-Remote-Calls">Executing Concurrent Remote Calls</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.6 Priority Inheritance</h4>

<p>It is compiler-dependent whether the caller priority is preserved during
a remote procedure call. In fact, it can be unsafe to rely on
priorities, because two partitions may have different priority ranges
and policies. Nevertheless, GLADE preserves the caller priority. This
priority is marshaled and unmarshaled during the remote procedure call
and the priority of the anonymous task on the server is set to the
caller priority.

   <p>This default policy can be modified by using pragma Priority
<a href="#Pragma-Priority">Pragma Priority</a> and partition attribute
Priority <a href="#Partition-Attribute-Priority">Partition Attribute Priority</a>.

<div class="node">
<p><hr>
<a name="Remote-Call-Abortion"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#User-Filter-Implementation">User Filter Implementation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Priority-Inheritance">Priority Inheritance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.7 Remote Call Abortion</h4>

<p>When a remote procedure call is aborted, GLADE will abort the calling
task on the caller side. It will also try to abort the remote anonymous
task performing the remote call. This task will be aborted without being
requeued in the anonymous tasks pool.

<div class="node">
<p><hr>
<a name="User-Filter-Implementation"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Remote-Call-Abortion">Remote Call Abortion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GLADE-Internals">GLADE Internals</a>
<br>
</div>

<h4 class="subsection">3.9.8 User Filter Implementation</h4>

<p>As has been briefly mentioned above, a filter with a name "NAME" must be
implemented in a package called <i>System.Garlic.Filters.Name</i>. The user
may write his own filters, which must implement their filtering of data
in the primitive operations of a type derived from the type
<i>System.Garlic.Filters.Filter_Type</i>. His filter package must then
register an instance of his newly derived type with GLADE by calling
<i>System.Garlic.Filters.Register</i>. From that on, his filter is ready to
be used.

   <p>For more information on how to write filter packages see the
sample implementation of a ZIP filter in files <tt>s-gafizi.ad[bs]</tt> in the
distribution. The user might also want to look at the example in the
<tt>Filtering</tt> directory of the GLADE distribution.

<div class="node">
<p><hr>
<a name="Remote-Shell-Notes"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#GLADE-Internals">GLADE Internals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>
<br>
</div>

<h3 class="section">3.10 Remote Shell Notes</h3>

<p>To start a partition, the main partition executes a remote shell -
except when the distributed application is built with a None
starter. Thus the user has to make sure that he is authorized to execute
a remote shell on the remote machine. In this case, a first step would
be to add into his $HOME/.rhosts file a line like : &lt;remote-machine&gt;
&lt;user-name&gt;

   <p>If he is not authorized at all, he can bypass this problem. All he has
to do is:

     <ul>
<li>Open a session on each machine listed in his configuration file.

     <li>If MAIN_PART is the partition that includes the main procedure and if
he wants to start MAIN_PART on host MAIN_HOST:

          <ul>
<li>Choose a TCP port number PORT_NUM

          <li>Then for each partition PART, start manually the corresponding
executable on the corresponding host as follows

          <pre class="smallexample">               % PART [--nolaunch] --boot_location tcp://MAIN_HOST:PORT_NUM
          </pre>
          <p>The &ndash;nolaunch parameter must be included for the main partition, it
means that this partition is not in charge of launching others.

     </ul>

     <li>If he wants to kill the distributed application before it terminates,
kill MAIN_PART.

   </ul>

<!-- @node -->
<!-- @section Restrictions -->
<!-- Static remote procedures, asynchronous remote procedures, remote -->
<!-- access to class wide types, remote access to subprogram and -->
<!-- asynchronous transfer of control with remote procedures are -->
<!-- implemented. Remote types packages are implemented. -->
<!-- Pragma All_Calls_Remote has been implemented. -->
<!-- Shared passive packages are unimplemented. -->
<!-- Language-defined exceptions propagate well through different -->
<!-- partitions. -->
<div class="node">
<p><hr>
<a name="DSA-and-CORBA"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-Started-With-GLADE">Getting Started With GLADE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="appendix">Appendix A DSA and CORBA</h2>

<ul class="menu">
<li><a accesskey="1" href="#CORBA-Architecture">CORBA Architecture</a>
<li><a accesskey="2" href="#Interface-Definition-Language">Interface Definition Language</a>
<li><a accesskey="3" href="#Network-Communication-Subsystem">Network Communication Subsystem</a>
<li><a accesskey="4" href="#Distributed-Application-Development">Distributed Application Development</a>
<li><a accesskey="5" href="#Some-Elements-of-Comparison">Some Elements of Comparison</a>
</ul>

<div class="node">
<p><hr>
<a name="CORBA-Architecture"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Interface-Definition-Language">Interface Definition Language</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSA-and-CORBA">DSA and CORBA</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DSA-and-CORBA">DSA and CORBA</a>
<br>
</div>

<h3 class="section">A.1 CORBA Architecture</h3>

<p>CORBA is an industry-sponsored effort to standardize the distributed
object paradigm via the CORBA Interface Definition Language (IDL).  The
use of IDL makes CORBA more self-describing than any other client/server
middleware. The Common Object Request Broker: Architecture and
Specification, revision 2.2 describes the main features of CORBA which
are Interface Definition Language, Language Mappings, Stubs, Skeletons
and Object Adapters, ORB, Interface Repository, Dynamic Invocation, ORB
protocols and CORBA services.

   <p><br>
<br>
<img src="corba-arch.fig.jpg" alt="corba-arch.fig.jpg">
<br>

   <p>The IDL specifies modules, constants, types and interfaces. An object
interface defines the operations, exceptions and public attributes a
client can invoke or access. CORBA offers a model based only on
distributed objects. In some respects, it can be compared to Java as
this language provides only an object-oriented programming model, and
discards the classical structured programming model.

   <p>An IDL translator generates client stubs and server skeletons in a host
language (<tt>C++</tt>, <tt>C</tt>, Java, Smalltalk, Ada95); a language mapping
specifies how IDL entities are implemented in the host
language. Depending on the features available in the host language, the
mapping can be more or less straightforward.  When an IDL feature is not
defined in the host language, the mapping provides a standardized but
complex way of simulating the missing feature.  Although the user works
with the generated code, a good understanding of the language mapping is
often necessary.

   <p>When the host language does not provide object-oriented features, the
user has to deal with a complex simulation of those functions. A <tt>C++</tt>
programmer has to follow several rules related to parameters passed by
reference. Defining whether the callee or the caller is responsible for
parameter memory allocation can be regarder as an issue of <tt>C++</tt> programming
conventions. The most difficult parts of the Ada mapping, which an Ada
programmer should avoid whenever possible, are multiple inheritance and
forward declarations.

   <p>The IDL translator produces several host language source files depending
on the language mapping: client files called stubs and server files
called skeletons. These files are specific to a vendor and product, as
they make calls to a proprietary communication subsystem, but their
structure and interface are supposed to follow a standard canvas.  The
client stubs convert user queries into requests to the ORB, which
transmits these requests through an object adapter to the server
skeleton.

<div class="node">
<p><hr>
<a name="Interface-Definition-Language"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Network-Communication-Subsystem">Network Communication Subsystem</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CORBA-Architecture">CORBA Architecture</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DSA-and-CORBA">DSA and CORBA</a>
<br>
</div>

<h3 class="section">A.2 Interface Definition Language</h3>

<p>In DSA, the IDL is a subset of Ada95. The user identifies interface packages
at compile time. Some library-level packages are categorized
using pragmas and these interface packages have to be library units.

   <p>In CORBA, the IDL is a description language; it supports <tt>C++</tt>
syntax for constant, type and operation declarations. From IDL
descriptions, a translator can directly generate client header files
and server implementation skeletons.

   <p>An IDL file can start by defining a module. This provides a name-space
to gather a set of interfaces. This is a way to introduce a level of
hierarchy (&lt;<i>module</i>&gt;::&lt;<i>interface</i>&gt;::&lt;<i>operation</i>&gt;). The Ada95
binding maps this element into a (child) package. <tt>#include</tt>
will make any other namespaces visible.

   <p>A module can define interfaces. An interface defines a set of methods
that a client can invoke on an object. An interface can also define
exceptions and attributes. An exception is like a <tt>C++</tt> exception: a
data component can be attached to it. An attribute is a component
field. For each <i>Attribute</i>, the implementation automatically creates
the subprograms Get_<i>Attribute</i> and Set_<i>Attribute</i>. Only Get is
provided for <i>readonly</i> attributes. An interface can derive from one
or more interfaces (multiple inheritance).

   <p>The Ada95 binding maps this element into a package or a child
package. For the client stub, the implementation will automatically
create a tagged type named Ref (which is derived from CORBA.Object.Ref
or from another Ref type defined in another interface) in a package
whose name matches the one of the interface. For the server skeleton,
the implementation will automatically create a tagged type named
Object (which is derived from an implementation defined private tagged
type Object) in a package named Impl, which is a child package of a
package named after the interface name (&lt;<tt>interface</tt>&gt;.Impl).

<pre class="smallexample">     
     <b>module</b> CosNaming {
       <b>typedef</b> string Istring;
       <b>struct</b> NameComponent {
         Istring id;
         Istring kind;
       };
       <b>typedef</b> <b>sequence</b> &lt;NameComponent&gt; Name;
       <b>enum</b> BindingType {nobject, ncontext};
       <b>struct</b> Binding {
         Name binding_name;
         BindingType binding_type;
       };
       <b>typedef</b> <b>sequence</b> &lt;Binding&gt; BindingList;
     
       <b>interface</b> BindingIterator;
     
       <b>interface</b> NamingContext {
           <b>exception</b> CannotProceed {
               NamingContext cxt;
               Name rest_of_name;
             };
           <b>void</b> bind (<b>in</b> Name n, <b>in</b> Object obj)
             <b>raises</b> (CannotProceed);
           <b>void</b> list
             (<b>in</b> unsigned long how_many,
              <b>out</b> BindingList bl,
              <b>out</b> BindingIterator bi);
           // Other declarations not shown
         };
     
       <b>interface</b> BindingIterator {
           boolean next_n
             (<b>in</b> unsigned long how_many,
              <b>out</b> BindingList bl);
           // Other declarations not shown
         };
     };
     
</pre>
   <p>A method is defined by a unique name (no overloading is allowed) and its
signature (the types of its formal parameters). Each parameter can be of
mode <b>in</b>, <b>out</b> or <b>inout</b>, whose meanings are comparable to
their Ada homonyms. Every exception that can be raised by a method must
also be declared as part of the method signature.

   <p>The <b>oneway</b> attribute can be applied to a subprogram, giving it
at-most-once semantics instead of the exactly-once default. 
This precludes a method from having output parameters, a return
value, or from raising an exception. It is not portable to assume that the
caller resumes its execution once the input parameters are transmitted.

   <p>Most CORBA data types map in a straightforward way onto predefined Ada
types, with the exception of <tt>any</tt> and <tt>sequence</tt>.  <tt>any</tt>, that
can designate any CORBA type, is mapped onto a stream type with <tt>read</tt>
and <tt>write</tt> operations. A <tt>sequence</tt> holds a list of items of a
given type and is represented in Ada using a pair of lengthy generic
packages. One may note that the CORBA <tt>string</tt> type is mapped onto the
<tt>Unbounded_String</tt> Ada95 type. The IDL does not provide an equivalent
to unconstrained arrays.

   <p>The Ada95 mapping provides special mechanisms to implement two
difficult-to-map CORBA features. First, it provides a translation of
multiple inheritance. As described above, an Ada95 package defines a
type derived from the first interface, and extends the list of its
primitive operations to achieve inheritance from other
interfaces. Another unnatural feature of CORBA for an Ada programmer
comes from forward declarations. In Ada, two package specifications
cannot &ldquo;with&rdquo; each others, but this can occur between two IDL
interfaces.  To solve this, the mapping can create &ldquo;forward&rdquo;
packages.  This can result in a very non-intuitive situation where the
client stub does not &ldquo;with&rdquo; its usual interface packages but
withs &ldquo;forward&rdquo; packages instead.

   <p>When developing a distributed application with CORBA, two situations
can arise. On the server side, the programmer is responsible for the
IDL file. He has to understand the Ada95 language mapping in order to
avoid structures with a non-trivial implementation whenever possible,
such as forward declaration and multiple inheritance. On both the server
and the client side, the programmer has to deal with the generated
code. A good understanding of the mapping is useful to get back and
forth from the IDL file to the generated code in order to keep an
overview of the distributed application. Understanding this mapping can
be a tedious task depending of the host language.

   <p>IDL interface information can be stored on-line in a database called
Interface Repository (IR). A CORBA specification describes how the
interface repository is organized and how to retrieve information from
it.  The reader will note that this information is close to what the Ada
Semantic Interface Specification (ASIS) can provide.

   <p>The interface repository allows a client to discover the signature of a
method which it did not know at compile time. It can subsequently use
this knowledge together with values for the method's parameters to
construct a complete request and invoke the method. The set of functions
that permits the construction of a method invocation request at run time
is the Dynamic Invocation Interface (DII).

   <p>The IR API allows the client to explore the repository classes to obtain
a module definition tree. From this tree, the client extracts subtrees
defining constants, types, exceptions, and interfaces. From an interface
subtree, the client can select an operation with its list of parameters
(type, name and mode) and exceptions.

   <p>A client has then three ways to make a request. As in the static case,
he can send it and wait for the result; he can also do a one-way call
and discard the result. With dynamic requests, a third mechanism is
offered: the client can send the request without waiting for the result,
and obtain it later, asynchronously.

   <p>The DII has a server-side counterpart, called Dynamic Skeleton
Interface (DSI). Both mechanisms are powerful but very complex and tedious to
use. In some respects, they also violate the Ada95 philosophy, because
strong typing is not preserved.  Most users will keep working with
static invocations.

<div class="node">
<p><hr>
<a name="Network-Communication-Subsystem"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Distributed-Application-Development">Distributed Application Development</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interface-Definition-Language">Interface Definition Language</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DSA-and-CORBA">DSA and CORBA</a>
<br>
</div>

<h3 class="section">A.3 Network Communication Subsystem</h3>

<p>The communication subsystem is one of the key points of a
distributed system: it offers basic services such as the capability to
transmit a message from one part of the distributed program to
another. Those elementary services are then used by higher level
services to build a fully functional distributed system.

   <p>The limit between what belongs to the communication subsystem and what
belongs to an external service may sometimes be difficult to draw. 
Moreover, something considered as a service in CORBA may be viewed as
purely internal in DSA.

<ul class="menu">
<li><a accesskey="1" href="#DSA-PCS">DSA PCS</a>
<li><a accesskey="2" href="#CORBA-ORB">CORBA ORB</a>
</ul>

<div class="node">
<p><hr>
<a name="DSA-PCS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#CORBA-ORB">CORBA ORB</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Network-Communication-Subsystem">Network Communication Subsystem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Network-Communication-Subsystem">Network Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">A.3.1 DSA PCS</h4>

<p>In the DSA world, everything that is not done by the compiler in
regard to the distribution belongs to the partition communication
subsystem (PCS). For example, figuring out on which partition a package
that will be called remotely is located is part of the PCS's
responsibility.

   <p>The PCS entry points are well defined in DSA, and described in the
<tt>System.RPC</tt> package declaration.  By looking at this package,
one can notice that there is nothing related to abortion of remote
subprogram calls, although the Annex states that if such a call is
aborted, an abortion message must be sent to the remote partition to
cancel remote processing. That means that the PCS is in charge of
detecting that a call to one of its entry points has been aborted and
must send such an abortion message, without any help from the
compiler.

   <p>Another interesting characteristic of the PCS is its behavior regarding
unknown exceptions. When an exception is raised as a result of the
execution of a remote subprogram call, it is propagated back to the
caller. However, the caller may not have any visibility over the
exception declaration, but may still catch it with a <tt>when
others</tt> clause. However, if the caller does not catch it and let it be
propagated upstream (maybe in another partition), and if the upstream
caller has visibility over this exception, it must be able to catch it
using its name. That means that the PCS must recognize that a
previously unknown exception maps onto a locally known one, for
example by being able to dynamically register a new exception into the
runtime.

<div class="node">
<p><hr>
<a name="CORBA-ORB"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSA-PCS">DSA PCS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Network-Communication-Subsystem">Network Communication Subsystem</a>
<br>
</div>

<h4 class="subsection">A.3.2 CORBA ORB</h4>

<p>In CORBA, a much more fragmented approach to communication services was adopted:
they are essentially defined externally.  For example, the naming
service (which maps object names to object references) is a
distributed object with a standard IDL interface.

   <p>While this approach seems more pure, it has performance drawbacks. 
Being itself a distributed object, the naming service cannot be
optimized for the needs of a specific ORB. A special case is also
required in the ORB for it to be able to locate the naming service
itself (chicken and egg problem): in order to get a reference on a
distributed object (an IOR, Interface Object Reference) to start with,
the programmer needs to have an IOR for the naming service.  This IOR
can be retrieved from the command line, from a file or by invoking the
ORB Interface, depending on the CORBA version.

   <p>Regarding exception propagation, an ORB is not able to propagate an
exception that has not been declared in the IDL interface. This
restriction, although annoying because it restricts the usage of
exceptions, is understandable given the multi-language CORBA approach:
what should be done, for example, when a <tt>C++</tt> exception reaches a
caller written in Ada? Note that an implementation may provide more
information in the CORBA exception message, such as the <tt>C++</tt> or Ada
exception name.

<div class="node">
<p><hr>
<a name="Distributed-Application-Development"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Some-Elements-of-Comparison">Some Elements of Comparison</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Network-Communication-Subsystem">Network Communication Subsystem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DSA-and-CORBA">DSA and CORBA</a>
<br>
</div>

<h3 class="section">A.4 Distributed Application Development</h3>

<ul class="menu">
<li><a accesskey="1" href="#DSA-Application-Development">DSA Application Development</a>
<li><a accesskey="2" href="#CORBA-Application-Development">CORBA Application Development</a>
</ul>

<div class="node">
<p><hr>
<a name="DSA-Application-Development"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#CORBA-Application-Development">CORBA Application Development</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Distributed-Application-Development">Distributed Application Development</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Distributed-Application-Development">Distributed Application Development</a>
<br>
</div>

<h4 class="subsection">A.4.1 DSA Application Development</h4>

<p>The DSA does not describe how a distributed application should be
configured. It is up to the user (using a partitioning tool whose
specification is outside the scope of the annex) to define what the
partitions in his program are and on which machines they should be
executed.

   <p>GLADE provides a Configuration Tool and a Partition Communication
Subsystem to build a distributed application. The <tt>gnatdist</tt> tool and
its configuration language have been specially designed to let the user
partition his program and specify the machines where the individual
partitions will be executing. The Generic Ada Reusable Library for
Interpartition Communication (GARLIC) is a high level communication
library that implements the interface between the Partition
Communication Subsystem defined in the Reference Manual and the network
communication layer with object-oriented techniques.

<div class="node">
<p><hr>
<a name="CORBA-Application-Development"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSA-Application-Development">DSA Application Development</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Distributed-Application-Development">Distributed Application Development</a>
<br>
</div>

<h4 class="subsection">A.4.2 CORBA Application Development</h4>

<p>The ORB provides a core of basic services. All other services are
provided by objects with IDL. The OMG has standardized a set of useful
services like Naming, Trading, Events, Licensing, Life Cycle, Events,
... A CORBA vendor is free to provide an implementation of these
services.

   <p>The Naming Service allows the association (<i>binding</i>) of an object
reference with user-friendly names. A name binding is always defined
relative to a <i>naming context</i> wherein it is unique. A naming context
is an object itself, and so can be bound to a name in another naming
context. One thus creates a <i>naming graph</i>, a directed graph with
naming contexts as vertices and names as edge labels. Given a context in
a naming graph, a sequence of names can thus reference an object. This
is very similar to the naming hierarchies that exist in the Domain Name
System and the UNIX file system. A typical scenario to start working
with the Name Service consists in providing a well-known remote
reference that defines the root of a naming and naming context
hierarchy. Then, many naming operations can be executed on this
hierarchy. The Trading Service provides a higher level of abstraction
than the Naming Service. If the Naming Service can be compared to the
White Pages, the Trading Service can be compared to the Yellow Pages.

   <p>The Events service provides a way for servers and clients to interact
through asynchronous events between anonymous objects. A <i>supplier</i>
produces events when a <i>consumer</i> receives notification and data. An
<i>event channel</i> is the mediator between consumers and
suppliers. <i>consumer admins</i> and <i>supplier admins</i> are in charge of
providing <i>proxies</i> to allow consumers and suppliers to get access to
the event channel. Suppliers and consumers produce and receive events
through their associated proxies. From the event channel point of view,
a <i>proxy supplier</i> (or <i>proxy consumer</i>) is seen as a consumer (or a
supplier).  Therefore, a proxy supplier (or proxy consumer) is an
extended interface of consumer (or supplier). The Events service defines
<i>push</i> and <i>pull</i> methods to exchange events. This allows to
define four models to exchange events and data.

<div class="node">
<p><hr>
<a name="Some-Elements-of-Comparison"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Distributed-Application-Development">Distributed Application Development</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DSA-and-CORBA">DSA and CORBA</a>
<br>
</div>

<h3 class="section">A.5 Some Elements of Comparison</h3>

<p>CORBA provides an outstanding and very popular framework. The IDL syntax
is close to <tt>C++</tt>. The object model is close to Java: CORBA defines
only distributed objects. Furthermore, when using the Ada mapping, the
stub and skeleton generated code is close to Java with two root classes,
Ref for clients and Object for servers.

   <p>DSA provides a more general model. This includes distributed objects,
but also regular remote subprograms and references to remote
subprograms. Shared passive packages can be defined as an abstraction
for a (distributed) shared memory, a persistency support or a database. 
Basically, the IDL is a subset of Ada95 and the remote services are
defined in packages categorized by three kinds of pragmas (RCI, RT,
SP). The distributed boundaries are more transparent as the application
is not split into IDL and host language sources.

   <p>In DSA, any Ada type can be used except access types, but this can be
solved by providing the marshaling operations for such a type. The
exception model is entirely preserved. Overloading is allowed in DSA
(not in CORBA). The user can also define generic packages and use mixin
mechanism to obtain some kind of multiple inheritance.

   <p>The DSA user can design, implement and test his application in a
non-distributed environment, and then switch to a distributed situation. 
With this two-phase design approach, the user always works within his
favorite Ada95 environment. The use of pragma All_Calls_Remote also
facilitates debugging of a distributed application in a non-distributed
context.

   <p>To work on client stubs or server skeletons, the CORBA user will have to
deal with generated code. In any case, understanding the host language
mapping is always very useful. It can be required for some languages
like <tt>C++</tt>. An Ada programmer should avoid using forward declaration
or multiple inheritance (and in some respects, sequence).

   <p>The CORBA user has to re-adapt his code to the code generated by the
translator from the IDL file any time the latter is modified. He also has
to use the predefined CORBA types instead of Ada standard types; he has
to call ORB functions or a naming service to obtain remote object
references.

   <p>As Ada95 is its own IDL, the user does not deal with any generated stub
or skeleton code. The configuration environment takes care of updating
object, stub and skeleton files when sources have been updated. The
system automatically provides some naming functions like declaring RCI
services. It also takes care of aborting remote procedure calls,
detecting distributed termination, checking version consistency between
clients and servers, and preserving and propagating any remote
exception. Note that none of these features are immediately available in
CORBA.

   <p>The RM does not require a DSA implementation to work on heterogeneous
systems but GLADE, like any reasonable implementation, provides default
XDR-like marshaling operations. This feature can be inhibited for
performance reasons. An ORB is required to implement a Common Data
Representation (CDR) to ensure safe communications between heterogeneous
systems.

   <p>CORBA is a very rich but very complex standard. Its drawbacks include
the high learning curve for developing and managing CORBA applications
effectively, performance limitations, as well as the lack of portability
and security. These drawbacks are the price to pay for language
interoperability, a facility the Ada95-oriented DSA does not provide.

   <p>Interoperability between compilers is not yet an issue with DSA because
there is only one implementation available (GLADE). But it is a
validation requirement to permit the user to replace his current PCS with
a third-party PCS. We can note this issue was not resolved in CORBA
until revision 2.2. For the same reasons, we can expect future DSA
implementations to ensure PCS compatibility.

   <p>Using its IDL, the OMG has described a number of <tt>Common Object
  Services</tt> (COS) that are frequently needed in distributed
systems. Unfortunately, these specifications are limited to IDL
descriptions, and most of the semantics are up to the vendor. The DSA
misses such user-level libraries, including basic distributed software
components.  More generally, the lack of component libraries has always
been a problem for Ada.

   <p>Implementing CORBA services as native Ada95 distributed objects, taking
advantage of the standard language features, yields a simpler, easy to
understand and use specification. We have already implemented the Naming
service, the Events service and a service close to the Concurrency one
with DSA. Developing the CORBA services was an interesting experience. 
We realized that although those services are nicely specified by an IDL
file, their semantics is quite vague in such a way portability is
dramatically broken. This work will be described in a future paper.

   <p>Another major goal of the GLADE team is to export DSA services to the
CORBA world.

   <p>The idea is to translate all DSA features to equivalent IDL features
using ASIS. This would allow the DSA user to connect his DSA server to an
ORB. This would also allow applications written in other languages to
invoke DSA features. We are also seeking to use this approach to offer a
DII mechanism for DSA.

<!-- ********************************** -->
<!-- * GNU Free Documentation License * -->
<!-- ********************************** -->
<div class="node">
<p><hr>
<a name="GNU-Free-Documentation-License"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#DSA-and-CORBA">DSA and CORBA</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="appendix">Appendix B GNU Free Documentation License</h2>

<p><a name="index-GNU-Free-Documentation-License_003a_003a-1"></a><a name="index-License_002c-GNU-Free-Documentation-2"></a><a name="index-Free-Documentation-License_002c-GNU-3"></a>
<!-- GNU Free Documentation License -->
Version 1.1, March 2000
   <pre class="sp">

</pre>
Copyright &copy; 2000 Free Software Foundation, Inc. 
<br>
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
   <pre class="sp">

</pre>
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

<h3 class="heading">0. PREAMBLE</h3>

<p>The purpose of this License is to make a manual, textbook, or other
written document &ldquo;free&rdquo; in the sense of freedom: to assure everyone
the effective freedom to copy and redistribute it, with or without
modifying it, either commercially or noncommercially.  Secondarily,
this License preserves for the author and publisher a way to get
credit for their work, while not being considered responsible for
modifications made by others.

   <p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

   <p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

<h3 class="heading">1. APPLICABILITY AND DEFINITIONS</h3>

<p>This License applies to any manual or other work that contains a
notice placed by the copyright holder saying it can be distributed
under the terms of this License.  The &ldquo;Document&rdquo;, below, refers to any
such manual or work.  Any member of the public is a licensee, and is
addressed as &ldquo;you&rdquo;.

   <p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

   <p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (For example, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

   <p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.

   <p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.

   <p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, whose contents can be viewed and edited directly and
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup has been designed to thwart or discourage
subsequent modification by readers is not Transparent.  A copy that is
not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.

   <p>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML designed for human modification.  Opaque formats include
PostScript, PDF, proprietary formats that can be read and edited only
by proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML produced by some word processors for output
purposes only.

   <p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

<h3 class="heading">2. VERBATIM COPYING</h3>

<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

   <p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

<h3 class="heading">3. COPYING IN QUANTITY</h3>

<p>If you publish printed copies of the Document numbering more than 100,
and the Document's license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition. 
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

   <p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

   <p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a publicly-accessible computer-network location containing a complete
Transparent copy of the Document, free of added material, which the
general network-using public has access to download anonymously at no
charge using public-standard network protocols.  If you use the latter
option, you must take reasonably prudent steps, when you begin
distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

   <p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

<h3 class="heading">4. MODIFICATIONS</h3>

<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
     <ol type=A start=1>
<li>Use in the Title Page (and on the covers, if any) a title distinct
   from that of the Document, and from those of previous versions
   (which should, if there were any, be listed in the History section
   of the Document).  You may use the same title as a previous version
   if the original publisher of that version gives permission. 
<li>List on the Title Page, as authors, one or more persons or entities
   responsible for authorship of the modifications in the Modified
   Version, together with at least five of the principal authors of the
   Document (all of its principal authors, if it has less than five). 
<li>State on the Title page the name of the publisher of the
   Modified Version, as the publisher. 
<li>Preserve all the copyright notices of the Document. 
<li>Add an appropriate copyright notice for your modifications
   adjacent to the other copyright notices. 
<li>Include, immediately after the copyright notices, a license notice
   giving the public permission to use the Modified Version under the
   terms of this License, in the form shown in the Addendum below. 
<li>Preserve in that license notice the full lists of Invariant Sections
   and required Cover Texts given in the Document's license notice. 
<li>Include an unaltered copy of this License. 
<li>Preserve the section entitled &ldquo;History&rdquo;, and its title, and add to
   it an item stating at least the title, year, new authors, and
   publisher of the Modified Version as given on the Title Page.  If
   there is no section entitled &ldquo;History&rdquo; in the Document, create one
   stating the title, year, authors, and publisher of the Document as
   given on its Title Page, then add an item describing the Modified
   Version as stated in the previous sentence. 
<li>Preserve the network location, if any, given in the Document for
   public access to a Transparent copy of the Document, and likewise
   the network locations given in the Document for previous versions
   it was based on.  These may be placed in the &ldquo;History&rdquo; section. 
   You may omit a network location for a work that was published at
   least four years before the Document itself, or if the original
   publisher of the version it refers to gives permission. 
<li>In any section entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;,
   preserve the section's title, and preserve in the section all the
   substance and tone of each of the contributor acknowledgements
   and/or dedications given therein. 
<li>Preserve all the Invariant Sections of the Document,
   unaltered in their text and in their titles.  Section numbers
   or the equivalent are not considered part of the section titles. 
<li>Delete any section entitled &ldquo;Endorsements&rdquo;.  Such a section
   may not be included in the Modified Version. 
<li>Do not retitle any existing section as &ldquo;Endorsements&rdquo;
   or to conflict in title with any Invariant Section.
        </ol>

   <p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice. 
These titles must be distinct from any other section titles.

   <p>You may add a section entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties &ndash; for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

   <p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

   <p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

<h3 class="heading">5. COMBINING DOCUMENTS</h3>

<p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice.

   <p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number. 
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

   <p>In the combination, you must combine any sections entitled &ldquo;History&rdquo;
in the various original documents, forming one section entitled
&ldquo;History&rdquo;; likewise combine any sections entitled &ldquo;Acknowledgements&rdquo;,
and any sections entitled &ldquo;Dedications&rdquo;.  You must delete all sections
entitled &ldquo;Endorsements.&rdquo;

   <p>Heading 6. COLLECTIONS OF DOCUMENTS

   <p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

   <p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

<h3 class="heading">7. AGGREGATION WITH INDEPENDENT WORKS</h3>

<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, does not as a whole count as a Modified Version
of the Document, provided no compilation copyright is claimed for the
compilation.  Such a compilation is called an &ldquo;aggregate&rdquo;, and this
License does not apply to the other self-contained works thus compiled
with the Document, on account of their being thus compiled, if they
are not themselves derivative works of the Document.

   <p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one quarter
of the entire aggregate, the Document's Cover Texts may be placed on
covers that surround only the Document within the aggregate. 
Otherwise they must appear on covers around the whole aggregate.

<h3 class="heading">8. TRANSLATION</h3>

<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4. 
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License provided that you also include the
original English version of this License.  In case of a disagreement
between the translation and the original English version of this
License, the original English version will prevail.

<h3 class="heading">9. TERMINATION</h3>

<p>You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.

<h3 class="heading">10. FUTURE REVISIONS OF THIS LICENSE</h3>

<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
http://www.gnu.org/copyleft/.

   <p>Each version of the License is given a distinguishing version number. 
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.

<h3 class="heading">ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
<blockquote>
Copyright (c)  YEAR  YOUR NAME. 
<br>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1
or any later version published by the Free Software Foundation;
with the Invariant Sections being LIST THEIR TITLES, with the
Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. 
A copy of the license is included in the section entitled &ldquo;GNU
Free Documentation License&rdquo;. 
</blockquote>

   <p>If you have no Invariant Sections, write &ldquo;with no Invariant Sections&rdquo;
instead of saying which ones are invariant.  If you have no
Front-Cover Texts, write &ldquo;no Front-Cover Texts&rdquo; instead of
&ldquo;Front-Cover Texts being LIST&rdquo;; likewise for Back-Cover Texts.

   <p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

<!-- GNU Free Documentation License -->
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">GLADE User Guide</a>
<li><a name="toc_About-This-Guide" href="#About-This-Guide">About This Guide</a>
<ul>
<li><a href="#What-This-Guide-Contains">What This Guide Contains</a>
</li></ul>
<li><a name="toc_Introduction-to-Distributed-Systems" href="#Introduction-to-Distributed-Systems">1 Introduction to Distributed Systems</a>
<ul>
<li><a href="#Using-OS-Network-Services">1.1 Using OS Network Services</a>
<li><a href="#Using-a-Middleware-Environment">1.2 Using a Middleware Environment</a>
<li><a href="#Using-a-Distributed-Language">1.3 Using a Distributed Language</a>
</li></ul>
<li><a name="toc_The-Distributed-Systems-Annex" href="#The-Distributed-Systems-Annex">2 The Distributed Systems Annex</a>
<ul>
<li><a href="#Architecture-of-a-Distributed-Ada95-Application">2.1 Architecture of a Distributed Ada95 Application</a>
<li><a href="#Categorization-Pragmas">2.2 Categorization Pragmas</a>
<li><a href="#Pragma-Declared-Pure">2.3 Pragma Declared Pure</a>
<li><a href="#Pragma-Remote_005fCall_005fInterface">2.4 Pragma Remote_Call_Interface</a>
<ul>
<li><a href="#Overview-of-Pragma-Remote_005fCall_005fInterface">2.4.1 Overview of Pragma Remote_Call_Interface</a>
<li><a href="#Regular-Remote-Subprograms-_0028RCI_0029">2.4.2 Regular Remote Subprograms (RCI)</a>
<li><a href="#Remote-Access-to-Subprograms-_0028RAS_0029">2.4.3 Remote Access to Subprograms (RAS)</a>
<li><a href="#Remote-Access-to-Class-Wide-Types-_0028RACW_0029">2.4.4 Remote Access to Class Wide Types (RACW)</a>
<li><a href="#Summary-on-Pragma-Remote_005fCall_005fInterface">2.4.5 Summary on Pragma Remote_Call_Interface</a>
</li></ul>
<li><a href="#Pragma-Remote_005fTypes">2.5 Pragma Remote_Types</a>
<ul>
<li><a href="#Overview-of-Pragma-Remote_005fTypes">2.5.1 Overview of Pragma Remote_Types</a>
<li><a href="#Distributed-Object">2.5.2 Distributed Object</a>
<li><a href="#Transmitting-Dynamic-Structure">2.5.3 Transmitting Dynamic Structure</a>
<li><a href="#Summary-on-Remote-Types-Units">2.5.4 Summary on Remote Types Units</a>
</li></ul>
<li><a href="#Pragma-Shared_005fPassive">2.6 Pragma Shared_Passive</a>
<ul>
<li><a href="#Overview-of-Pragma-Shared_005fPassive">2.6.1 Overview of Pragma Shared_Passive</a>
<li><a href="#Overview-of-Pragma-Shared_005fPassive">2.6.2 Shared and Protected Objects</a>
<li><a href="#Summary-on-Pragma-Shared_005fPassive">2.6.3 Summary on Pragma Shared_Passive</a>
</li></ul>
<li><a href="#More-About-Categorization-Pragmas">2.7 More About Categorization Pragmas</a>
<ul>
<li><a href="#Variables-and-Non_002dRemote-Access-Types">2.7.1 Variables and Non-Remote Access Types</a>
<li><a href="#RPC-Failures">2.7.2 RPC Failures</a>
<li><a href="#Exceptions">2.7.3 Exceptions</a>
<li><a href="#Pragma-Asynchronous">2.7.4 Pragma Asynchronous</a>
<li><a href="#Pragma-All_005fCalls_005fRemote">2.7.5 Pragma All_Calls_Remote</a>
<li><a href="#Generic-Categorized-Units">2.7.6 Generic Categorized Units</a>
<li><a href="#Categorization-Unit-Dependencies">2.7.7 Categorization Unit Dependencies</a>
</li></ul>
<li><a href="#Partition-Communication-Subsystem">2.8 Partition Communication Subsystem</a>
<ul>
<li><a href="#Marshaling-and-Unmarshaling-Operations">2.8.1 Marshaling and Unmarshaling Operations</a>
<li><a href="#Incorrect-Remote-Dispatching">2.8.2 Incorrect Remote Dispatching</a>
<li><a href="#Partition-Ids">2.8.3 Partition Ids</a>
<li><a href="#Concurrent-Remote-Calls">2.8.4 Concurrent Remote Calls</a>
<li><a href="#Consistency-and-Elaboration">2.8.5 Consistency and Elaboration</a>
<li><a href="#Abortion-and-Termination">2.8.6 Abortion and Termination</a>
</li></ul>
<li><a href="#Most-Features-in-One-Example">2.9 Most Features in One Example</a>
</li></ul>
<li><a name="toc_Getting-Started-With-GLADE" href="#Getting-Started-With-GLADE">3 Getting Started With GLADE</a>
<ul>
<li><a href="#Introduction-to-GLADE">3.1 Introduction to GLADE</a>
<li><a href="#How-to-Configure-a-Distributed-Application">3.2 How to Configure a Distributed Application</a>
<li><a href="#Gnatdist-Command-Line-Options">3.3 Gnatdist Command Line Options</a>
<li><a href="#Gnatdist-Behind-the-Scenes">3.4 Gnatdist Behind the Scenes</a>
<li><a href="#The-Configuration-Language">3.5 The Configuration Language</a>
<ul>
<li><a href="#Language-Keywords">3.5.1 Language Keywords</a>
<li><a href="#Pragmas-and-Representation-Clauses">3.5.2 Pragmas and Representation Clauses</a>
<li><a href="#Configuration-Declaration">3.5.3 Configuration Declaration</a>
<li><a href="#Partition-Declaration">3.5.4 Partition Declaration</a>
<li><a href="#Location-Declaration">3.5.5 Location Declaration</a>
<li><a href="#Partition-Attribute-Main">3.5.6 Partition Attribute Main</a>
<li><a href="#Pragma-Starter">3.5.7 Pragma Starter</a>
<li><a href="#Pragma-Starter">3.5.8 Pragma Remote_Shell</a>
<li><a href="#Pragma-Boot_005fLocation">3.5.9 Pragma Boot_Location</a>
<li><a href="#Partition-Attribute-Self_005fLocation">3.5.10 Partition Attribute Self_Location</a>
<li><a href="#Partition-Attribute-Passive">3.5.11 Partition Attribute Passive</a>
<li><a href="#Partition-Attribute-Data_005fLocation">3.5.12 Partition Attribute Data_Location</a>
<li><a href="#Partition-Attribute-Allow_005fLight_005fPCS">3.5.13 Partition Attribute Allow_Light_PCS</a>
<li><a href="#Pragma-Priority">3.5.14 Pragma Priority</a>
<li><a href="#Partition-Attribute-Priority">3.5.15 Partition Attribute Priority</a>
<li><a href="#Partition-Attribute-Host">3.5.16 Partition Attribute Host</a>
<li><a href="#Pragma-Import">3.5.17 Pragma Import</a>
<li><a href="#Partition-Attribute-Directory">3.5.18 Partition Attribute Directory</a>
<li><a href="#Partition-Attribute-Command_005fLine">3.5.19 Partition Attribute Command_Line</a>
<li><a href="#Partition-Attribute-Termination">3.5.20 Partition Attribute Termination</a>
<li><a href="#Partition-Attribute-Reconnection">3.5.21 Partition Attribute Reconnection</a>
<li><a href="#Channel-Declaration">3.5.22 Channel Declaration</a>
<li><a href="#Partition-and-Channel-Attribute-Filter">3.5.23 Partition and Channel Attribute Filter</a>
<li><a href="#Pragma-Registration_005fFilter">3.5.24 Pragma Registration_Filter</a>
<li><a href="#Pragma-Version">3.5.25 Pragma Version</a>
<li><a href="#Partition-Attribute-Task_005fPool">3.5.26 Partition Attribute Task_Pool</a>
<li><a href="#A-Complete-Example">3.5.27 A Complete Example</a>
</li></ul>
<li><a href="#Partition-Command-Line-Options">3.6 Partition Command Line Options</a>
<ul>
<li><a href="#Partition-Option-boot_005flocation">3.6.1 Partition Option boot_location</a>
<li><a href="#Partition-Option-self_005flocation">3.6.2 Partition Option self_location</a>
<li><a href="#Partition-Option-data_005flocation">3.6.3 Partition Option data_location</a>
<li><a href="#Partition-Option-nolaunch">3.6.4 Partition Option nolaunch</a>
<li><a href="#Partition-Option-detach">3.6.5 Partition Option detach</a>
<li><a href="#Partition-Option-slave">3.6.6 Partition Option slave</a>
<li><a href="#Partition-Option-boot_005fmirror">3.6.7 Partition Option boot_mirror</a>
<li><a href="#Partition-Option-mirror_005fexpected">3.6.8 Partition Option mirror_expected</a>
<li><a href="#Partition-Option-connection_005fhits">3.6.9 Partition Option connection_hits</a>
<li><a href="#Partition-Option-reconnection">3.6.10 Partition Option reconnection</a>
<li><a href="#Partition-Option-termination">3.6.11 Partition Option termination</a>
<li><a href="#Partition-Option-trace">3.6.12 Partition Option trace</a>
<li><a href="#Partition-Option-replay">3.6.13 Partition Option replay</a>
</li></ul>
<li><a href="#Debugging-Facilities">3.7 Debugging Facilities</a>
<li><a href="#GLADE-File-Hierarchy">3.8 GLADE File Hierarchy</a>
<li><a href="#GLADE-Internals">3.9 GLADE Internals</a>
<ul>
<li><a href="#The-GARLIC-PCS">3.9.1 The GARLIC PCS</a>
<li><a href="#The-PolyORB-PCS">3.9.2 The PolyORB PCS</a>
<li><a href="#Heterogeneous-System">3.9.3 Heterogeneous System</a>
<li><a href="#Allocating-Partition-Ids">3.9.4 Allocating Partition Ids</a>
<li><a href="#Executing-Concurrent-Remote-Calls">3.9.5 Executing Concurrent Remote Calls</a>
<li><a href="#Priority-Inheritance">3.9.6 Priority Inheritance</a>
<li><a href="#Remote-Call-Abortion">3.9.7 Remote Call Abortion</a>
<li><a href="#User-Filter-Implementation">3.9.8 User Filter Implementation</a>
</li></ul>
<li><a href="#Remote-Shell-Notes">3.10 Remote Shell Notes</a>
</li></ul>
<li><a name="toc_DSA-and-CORBA" href="#DSA-and-CORBA">Appendix A DSA and CORBA</a>
<ul>
<li><a href="#CORBA-Architecture">A.1 CORBA Architecture</a>
<li><a href="#Interface-Definition-Language">A.2 Interface Definition Language</a>
<li><a href="#Network-Communication-Subsystem">A.3 Network Communication Subsystem</a>
<ul>
<li><a href="#DSA-PCS">A.3.1 DSA PCS</a>
<li><a href="#CORBA-ORB">A.3.2 CORBA ORB</a>
</li></ul>
<li><a href="#Distributed-Application-Development">A.4 Distributed Application Development</a>
<ul>
<li><a href="#DSA-Application-Development">A.4.1 DSA Application Development</a>
<li><a href="#CORBA-Application-Development">A.4.2 CORBA Application Development</a>
</li></ul>
<li><a href="#Some-Elements-of-Comparison">A.5 Some Elements of Comparison</a>
</li></ul>
<li><a name="toc_GNU-Free-Documentation-License" href="#GNU-Free-Documentation-License">Appendix B GNU Free Documentation License</a>
</li></ul>
</div>

<!-- Put table of contents at end, otherwise it precedes the "title page" in -->
<!-- the .txt version -->
<!-- Edit the pdf file to move the contents to the beginning, after the title -->
<!-- page -->
<div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> <tt>ESTEREL</tt> is an imperative synchronous language
designed for the specification and the development of reactive systems.</p>

   <p><hr></div>

</body></html>

